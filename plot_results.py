__author__ = 'milsteina'
from optimize_cells_utils import *
import matplotlib as mpl
import matplotlib.lines as mlines
import scipy.stats as stats
import matplotlib.gridspec as gridspec
from matplotlib import cm
#from dentate.cells import *
from dentate.synapses import get_syn_mech_param, get_syn_filter_dict

mpl.rcParams['svg.fonttype'] = 'none'
mpl.rcParams['font.size'] = 12.
# mpl.rcParams['font.size'] = 14.
#mpl.rcParams['font.sans-serif'] = 'Arial'
#mpl.rcParams['font.sans-serif'] = 'Calibri'
mpl.rcParams['font.sans-serif'] = 'Myriad Pro'
mpl.rcParams['text.usetex'] = False
#mpl.rcParams['figure.figsize'] = 6, 4.3
"""
mpl.rcParams['axes.labelsize'] = 'larger'
mpl.rcParams['axes.titlesize'] = 'xx-large'
mpl.rcParams['xtick.labelsize'] = 'large'
mpl.rcParams['ytick.labelsize'] = 'large'
mpl.rcParams['legend.fontsize'] = 'x-large'
"""


def plot_Rinp(rec_file_list, sec_types_list=None, features_list=None, features_labels=None, file_labels=None,
              data_dir='data/'):
    """
    Expects each file in list to be generated by parallel_rinp.
    Superimpose features across cells recorded from simulated step current injections to probe input resistance and
    membrane time constant.
    :return:
    """
    orig_fontsize = mpl.rcParams['font.size']
    mpl.rcParams['font.size'] = 18.
    if isinstance(rec_file_list, str):
        rec_file_list = [rec_file_list]
    if isinstance(sec_types_list, str):
        sec_types_list = [sec_types_list]
    if isinstance(features_list, str):
        features_list = [features_list]
    if isinstance(features_labels, str):
        features_labels = [features_labels]
    if isinstance(file_labels, str):
        file_labels = [file_labels]
    if sec_types_list is None:
        sec_types_list = ['axon', 'apical', 'soma']
    axon_types_list = ['axon', 'ais', 'axon_hill']
    dend_types_list = ['basal', 'apical', 'trunk', 'tuft']
    if features_list is None:
        features_list = ['Rinp_peak', 'Rinp_baseline', 'Rinp_steady', 'decay_90']
    if features_labels is None:
        features_labels_default_dict = {'Rinp_peak': 'Input resistance - peak (MOhm)', 'Rinp_baseline': 'Baseline Vm (mV)',
                                'Rinp_steady': 'Input resistance - steady-state (MOhm)',
                                'decay_90': 'Membrane time constant (ms)'}
        features_labels_dict = {}
        for feature in features_list:
            if feature in features_labels_default_dict:
                features_labels_dict[feature] = features_labels_default_dict[feature]
            else:
                features_labels_dict[feature] = feature
    else:
        features_labels_dict = {feature: label for (feature, label) in zip(features_list, features_labels)}
    ax_list = []
    for file_index, rec_file in enumerate(rec_file_list):
        feature_dict = {feature: {} for feature in features_list}
        distances_dict = {feature: {} for feature in features_list}
        with h5py.File(data_dir + rec_file + '.hdf5', 'r') as f:
            for item in f['Rinp_data'].itervalues():
                if ((item.attrs['type'] in sec_types_list) or
                        ('axon' in sec_types_list and item.attrs['type'] in axon_types_list) or
                        ('dendrite' in sec_types_list and item.attrs['type'] in dend_types_list)):
                    if 'axon' in sec_types_list and item.attrs['type'] in axon_types_list:
                        sec_type = 'axon'
                    elif 'dendrite' in sec_types_list and item.attrs['type'] in dend_types_list:
                        sec_type = 'dendrite'
                    else:
                        sec_type = item.attrs['type']
                    for feature in features_list:
                        if sec_type not in distances_dict[feature].keys():
                            distances_dict[feature][sec_type] = []
                        if item.attrs['type'] in ['basal', 'axon', 'ais', 'axon_hill']:
                            distances_dict[feature][sec_type].append(item.attrs['soma_distance'] * -1.)
                        else:
                            distances_dict[feature][sec_type].append(item.attrs['soma_distance'])
                        if sec_type not in feature_dict[feature].keys():
                            feature_dict[feature][sec_type] = []
                        feature_dict[feature][sec_type].append(item.attrs[feature])
        num_colors = 10
        color_x = np.linspace(0., 1., num_colors)
        colors = [cm.Set1(x) for x in color_x]
        for index, feature in enumerate(features_list):
            if len(ax_list) <= index:
                fig, ax = plt.subplots(1)
                ax_list.append(ax)
            for i, sec_type in enumerate(sec_types_list):
                if file_labels is None:
                    label = sec_type
                elif len(sec_types_list) == 1:
                    label = file_labels[file_index]
                else:
                    label = file_labels[file_index] + ': ' + sec_type
                ax_list[index].scatter(distances_dict[feature][sec_type], feature_dict[feature][sec_type],
                            label=label, color = colors[file_index*len(sec_types_list) + i], alpha=0.5)
            ax_list[index].set_xlabel('Distance to soma')
            ax_list[index].set_ylabel(features_labels_dict[feature])
            ax_list[index].legend(loc='best', scatterpoints = 1, frameon=False, framealpha=0.5)
            clean_axes(ax_list[index])
    plt.show()
    plt.close()
    mpl.rcParams['font.size'] = orig_fontsize


def plot_Rinp_curr_inj(rec_file, rec_num):
    """

    :param rec_file: str
    :return:
    """
    with h5py.File(data_dir + rec_file + '.hdf5', 'r') as f:
        y_vals = f[str(rec_num)]['stim']['0'][:]
        x_vals = f[str(rec_num)]['time']
        fig, axes = plt.subplots(1)
        #axes.scatter(x_vals, y_vals)
        axes.plot(x_vals, y_vals)
        axes.set_xlabel('Time (ms')
        axes.set_ylabel('Injected current (nA)')
        clean_axes(axes)
        fig.tight_layout()
    plt.show()
    plt.close()


def plot_Rinp_avg_waves(rec_file_list, sec_types_list=None, file_labels=None):
    """
    Expects each file in list to be generated by parallel_rinp.
    avg_waves contains voltage waves averaged across similar sec_types (dendritic sections are divided into proximal
    and distal) recorded from simulated step current injections to probe input resistance and membrane time constant.
    :param rec_file_list: str or list of str
    :param sec_types_list:  str or list of str
    :param file_labels:  str or list of str
    """
    orig_fontsize = mpl.rcParams['font.size']
    mpl.rcParams['font.size'] = 18.
    if isinstance(rec_file_list, str):
        rec_file_list = [rec_file_list]
    if isinstance(sec_types_list, str):
        sec_types_list = [sec_types_list]
    if isinstance(file_labels, str):
        file_labels = [file_labels]
    if sec_types_list is None:
        sec_types_list = ['soma', 'prox_apical', 'dist_apical']
    num_colors = 10
    color_x = np.linspace(0., 1., num_colors)
    colors = [cm.Set1(x) for x in color_x]
    ax_list = []
    for i, item in enumerate(sec_types_list):
        if len(ax_list) <= i:
            fig, ax = plt.subplots(1)
            ax_list.append(ax)
        for file_index, rec_file in enumerate(rec_file_list):
            with h5py.File(data_dir + rec_file + '.hdf5', 'r') as f:
                if item in f['avg_waves']:
                    if file_labels is not None:
                        label = file_labels[file_index]
                        ax_list[i].plot(f['avg_waves']['time'], f['avg_waves'][item], label=label,
                                        color=colors[file_index])
                    else:
                        ax_list[i].plot(f['avg_waves']['time'], f['avg_waves'][item], color=colors[file_index])
                ax_list[i].set_xlabel('Time (ms)')
                ax_list[i].set_ylabel('Voltage (mV)')
                if file_labels is not None:
                    ax_list[i].legend(loc='best', scatterpoints = 1, frameon=False, framealpha=0.5)
                ax_list[i].set_title(item)
                clean_axes(ax_list[i])
    plt.show()
    plt.close()
    mpl.rcParams['font.size'] = orig_fontsize


def plot_superimpose_conditions(rec_filename, legend=False):
    """
    File contains simulation results from iterating through some changes in parameters or stimulation conditions.
    This function produces one plot per recorded vector. Each plot superimposes the recordings from each of the
    simulation iterations.
    :param rec_filename: str
    :param legend: bool
    """
    f = h5py.File(data_dir+rec_filename+'.hdf5', 'r')
    rec_ids = []
    sim_ids = []
    for sim in f.itervalues():
        if 'description' in sim.attrs and not sim.attrs['description'] in sim_ids:
            sim_ids.append(sim.attrs['description'])
        for rec in sim['rec'].itervalues():
            if 'description' in rec.attrs:
                rec_id = rec.attrs['description']
            else:
                rec_id = rec.attrs['type']+str(rec.attrs['index'])
            if not rec_id in (id['id'] for id in rec_ids):
                rec_ids.append({'id': rec_id, 'ylabel': rec.attrs['ylabel']+' ('+rec.attrs['units']+')'})
    fig, axes = plt.subplots(1, max(2, len(rec_ids)))
    for i in range(len(rec_ids)):
        axes[i].set_xlabel('Time (ms)')
        axes[i].set_ylabel(rec_ids[i]['ylabel'])
        axes[i].set_title(rec_ids[i]['id'])
    for sim in f.itervalues():
        if 'description' in sim.attrs:
            sim_id = sim.attrs['description']
        else:
            sim_id = ''
        tvec = sim['time']
        for rec in sim['rec'].itervalues():
            if ('description' in rec.attrs):
                rec_id = rec.attrs['description']
            else:
                rec_id = rec.attrs['type']+str(rec.attrs['index'])
            i = [index for index, id in enumerate(rec_ids) if id['id'] == rec_id][0]
            axes[i].plot(tvec[:], rec[:], label=sim_id)
    if legend:
        for i in range(len(rec_ids)):
            axes[i].legend(loc='best', framealpha=0.5, frameon=False)
    plt.subplots_adjust(hspace=0.4, wspace=0.3, left=0.05, right=0.95, top=0.95, bottom=0.1)
    plt.show()
    plt.close()
    f.close()


def plot_synaptic_parameter(rec_file_list, description_list=None):
    """
    Expects each file in list to be generated by optimize_EPSP_amp.
    Files contain one group for each type of dendritic section. Groups contain distances from soma and values for all
    measured synaptic parameters. Produces one column of plots per sec_type, one row of plots per parameter, and
    superimposes data from each rec_file.
    :param rec_file_list: list of str
    :param description_list: list of str
    """
    if not type(rec_file_list) == list:
        rec_file_list = [rec_file_list]
    if description_list is None:
        description_list = [" " for rec in rec_file_list]
    with h5py.File(data_dir+rec_file_list[0]+'.hdf5', 'r') as f:
        param_list = [dataset for dataset in f.itervalues().next() if not dataset == 'distances']
        fig, axes = plt.subplots(max(2,len(param_list)), max(2, len(f)))
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    for index, rec_filename in enumerate(rec_file_list):
        with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as f:
            for i, sec_type in enumerate(f):
                for j, dataset in enumerate(param_list):
                    axes[j][i].scatter(f[sec_type]['distances'][:], f[sec_type][dataset][:],
                                       label=description_list[index], color=colors[index])
                    axes[j][i].set_title(sec_type+' synapses')
                    axes[j][i].set_xlabel('Distance to soma (um)')
                    axes[j][i].set_ylabel(f.attrs['syn_type']+': '+dataset+'\n'+f.attrs[dataset])
    plt.legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5)
    plt.subplots_adjust(hspace=0.4, wspace=0.3, left=0.09, right=0.98, top=0.95, bottom=0.05)
    plt.show()
    plt.close()


def plot_synaptic_parameter_GC(rec_file_list, param_names=None, description_list=None):
    """
    Expects each file in list to be generated by optimize_EPSP_amp.
    Files contain one group for each type of dendritic section. Groups contain distances from soma and values for all
    measured synaptic parameters. Produces one column of plots per sec_type, one row of plots per parameter, and
    superimposes data from each rec_file.
    :param rec_file_list: list of str
    :param description_list: list of str
    """
    if not type(rec_file_list) == list:
        rec_file_list = [rec_file_list]
    default_input_locs = ['apical']
    # default_rec_locs = ['soma']
    with h5py.File(data_dir+rec_file_list[0]+'.hdf5', 'r') as f:
        if param_names is None:
            param_names = [param_name for param_name in f.values()[0].attrs.keys() if not (param_name == 'input_loc' or param_name == 'equilibrate'
                           or param_name == 'duration')]
        temp_input_locs = []
        temp_rec_locs = []
        for sim in f.itervalues():
            input_loc = sim.attrs['input_loc']
            if not input_loc in temp_input_locs:
                temp_input_locs.append(input_loc)
    # enforce the default order of input and recording locations for plotting, but allow for adding or subtracting
    # sec_types
    input_locs = [input_loc for input_loc in default_input_locs if input_loc in temp_input_locs]+\
                 [input_loc for input_loc in temp_input_locs if not input_loc in default_input_locs]
    distances_soma = {}
    #distances_dend = {}
    param_vals = {}
    for param_name in param_names:
        param_vals[param_name] = {}
    for index, rec_filename in enumerate(rec_file_list):
        for input_loc in input_locs:
            distances_soma[input_loc] = {}
            #distances_dend[input_loc] = {}
            for param_name in param_names:
                param_vals[param_name][input_loc] = {}
        with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as f:
            for sim in f.itervalues():
                input_loc = sim.attrs['input_loc']
                is_terminal = str(sim['rec']['2'].attrs['is_terminal'])
                if is_terminal not in distances_soma[input_loc].keys():
                    distances_soma[input_loc][is_terminal] = []
                    #distances_dend[input_loc][is_terminal] = []
                distances_soma[input_loc][is_terminal].append(sim['rec']['2'].attrs['soma_distance'])
                #distances_dend[input_loc][is_terminal].append(sim['rec']['2'].attrs['soma_distance'] -
                                                                        #sim['rec']['1'].attrs['soma_distance'])
                for param_name in param_names:
                    if is_terminal not in param_vals[param_name][input_loc].keys():
                        param_vals[param_name][input_loc][is_terminal] = []
                    param_vals[param_name][input_loc][is_terminal].append(sim.attrs[param_name])
            fig, axes = plt.subplots(max(2, len(input_locs)), max(2, len(param_names)))
            # fig, axes = plt.subplots(max(2, len(input_locs)*2), max(2, len(param_names)))
            colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
            for i, input_loc in enumerate(input_locs):
                for j, param_name in enumerate(param_names):
                    string_keys = distances_soma[input_loc].keys()
                    terminal_keys = [int(key) for key in string_keys]
                    terminal_keys.sort()
                    terminal_labels = []
                    for key in terminal_keys:
                        if key == 0:
                            terminal_labels.append('not term.')
                        else:
                            terminal_labels.append('terminal')
                    for ind, is_terminal in enumerate([str(key) for key in terminal_keys]):
                        axes[i][j].scatter(distances_soma[input_loc][is_terminal], param_vals[param_name][input_loc][is_terminal],
                                           color=colors[ind], label=terminal_labels[ind])
                        #axes[i + len(input_locs)][j].scatter(distances_dend[input_loc][is_terminal],
                                            # param_vals[param_name][input_loc][is_terminal], color=colors[ind], label=terminal_labels[ind])
                    axes[i][j].legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5)
                    #axes[i + len(input_locs)][j].legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5)
                    axes[i][j].set_xlabel('Distance from Soma (um)')
                    #axes[i + len(input_locs)][j].set_xlabel('Distance from Dendritic Origin (um)')
                    axes[0][j].set_title('Parameter: ' + param_name, fontsize=mpl.rcParams['font.size'])
                axes[i][0].set_ylabel('Synapse Location: '+input_loc+'\n'+param_name)
                #axes[i + len(input_locs)][0].set_ylabel('Synapse Location: ' + input_loc + '\n'+param_name)

    fig.subplots_adjust(hspace=0.25, wspace=0.3, left=0.07, right=0.98, top=0.94, bottom=0.1)
    clean_axes(axes.flatten())
    plt.show()
    plt.close()


def plot_synaptic_attribute_distribution(cell, env, syn_name, param_name, filters=None, from_mech_attrs=True,
                                         from_target_attrs=False, export=None, overwrite=False, description=None,
                                         scale_factor=1., param_label=None, ylabel='Peak conductance', yunits='uS',
                                         svg_title=None, show=True, sec_types=None, data_dir='data'):
    """
    Plots values of synapse attributes found in point processes and NetCons of a Hoc Cell. No simulation is required;
    this method just takes a fully specified cell and plots the relationship between distance and the specified synaptic
    parameter.

    Note: exported files can be plotted using plot_syn_attr_from_file; give syn_name as the input parameter instead of
    mech_name.

    :param cell: :class:'BiophysCell'
    :param env: :class:'Env'
    :param syn_name: str
    :param param_name: str
    :param filters: dict (ex. syn_indexes, layers, syn_types) with str values
    :param from_mech_attrs: bool
    :param from_target_attrs: bool
    :param export: str (name of hdf5 file for export)
    :param overwrite: bool (whether to overwrite or append to potentially existing hdf5 file)
    :param description: str (to be saved in hdf5 file as a descriptor of this session)
    :param scale_factor: float
    :param param_label: str
    :param ylabel: str
    :param yunits: str
    :param svg_title: str
    :param show: bool (whether to show the plot, or simply save the hdf5 file)
    :param sec_types: list or str
    :param data_dir: str
    :return:
    """
    if svg_title is not None:
        remember_font_size = mpl.rcParams['font.size']
        mpl.rcParams['font.size'] = 20
    if sec_types is None or (isinstance(sec_types, str) and sec_types == 'dend'):
        sec_types = ['basal', 'trunk', 'apical', 'tuft']
    elif isinstance(sec_types, str) and sec_types == 'all':
        sec_types = default_ordered_sec_types
    elif not all(sec_type in default_ordered_sec_types for sec_type in sec_types):
        raise ValueError('plot_synaptic_attribute_distribution: unrecognized sec_types: %s' % str(sec_types))
    sec_types_list = [sec_type for sec_type in sec_types if sec_type in cell.nodes and len(cell.nodes[sec_type]) > 0]
    attr_types = []
    if from_mech_attrs:
        attr_types.append('mech_attrs')
    if from_target_attrs:
        attr_types.append('target_attrs')
    if len(attr_types) == 0:
        raise Exception('plot_synaptic_attribute_distribution: both from_mech_attrs and from_target_attrs cannot be '
                        'False')
    distances = {attr_type: defaultdict(list) for attr_type in attr_types}
    attr_vals = {attr_type: defaultdict(list) for attr_type in attr_types}
    num_colors = 10
    color_x = np.linspace(0., 1., num_colors)
    colors = [cm.Set1(x) for x in color_x]
    syn_attrs = env.synapse_attributes
    gid = cell.gid
    for sec_type in sec_types_list:
        if len(cell.nodes[sec_type]) > 0:
            for node in cell.nodes[sec_type]:
                syn_idxs = syn_attrs.sec_index_map[gid][node.index]
                syn_ids = syn_attrs.syn_id_attr_dict[gid]['syn_ids'][syn_idxs]
                if filters is not None:
                    converted_filters = get_syn_filter_dict(env, filters, convert=True)
                    filtered_idxs = syn_attrs.get_filtered_syn_indexes(gid, syn_ids, **converted_filters)
                    syn_ids = syn_attrs.syn_id_attr_dict[gid]['syn_ids'][filtered_idxs]
                for syn_id in syn_ids:
                    # TODO: figure out what to do with spine synapses that are not inserted into a branch node
                    if from_mech_attrs:
                        this_param_val = syn_attrs.get_mech_attrs(gid, syn_id, syn_name)
                        if this_param_val is not None:
                            attr_vals['mech_attrs'][sec_type].append(this_param_val[param_name] * scale_factor)
                            syn_loc = syn_attrs.syn_id_attr_dict[gid]['syn_locs'][syn_attrs.syn_id_attr_index_map[gid][syn_id]]
                            distances['mech_attrs'][sec_type].append(get_distance_to_node(cell, cell.tree.root, node, syn_loc))
                            if sec_type == 'basal':
                                distances['mech_attrs'][sec_type][-1] *= -1
                    if from_target_attrs:
                        if syn_attrs.has_netcon(cell.gid, syn_id, syn_name):
                            this_nc = syn_attrs.get_netcon(cell.gid, syn_id, syn_name)
                            attr_vals['target_attrs'][sec_type].append(get_syn_mech_param(syn_name, syn_attrs.syn_param_rules,
                                                                                          param_name,
                                                                                          mech_names=syn_attrs.syn_mech_names,
                                                                                          nc=this_nc) * scale_factor)
                            syn_loc = syn_attrs.syn_id_attr_dict[gid]['syn_locs'][syn_attrs.syn_id_attr_index_map[gid][syn_id]]
                            distances['target_attrs'][sec_type].append(get_distance_to_node(cell, cell.tree.root, node, syn_loc))
                            if sec_type == 'basal':
                                distances['target_attrs'][sec_type][-1] *= -1
    for attr_type in attr_types:
        if len(attr_vals[attr_type]) == 0 and export is not None:
            print 'Not exporting to %s; mechanism: %s parameter: %s not found in any sec_type' % \
                  (export, syn_name, param_name)
            return
    xmax0 = 0.1
    xmin0 = 0.
    maxval, minval = 0., 0.
    fig, axarr = plt.subplots(ncols=len(attr_types), sharey=True)
    for i, attr_type in enumerate(attr_types):
        if len(attr_types) == 1:
            axes = axarr
        else:
            axes = axarr[i]
        for j, sec_type in enumerate(attr_vals[attr_type]):
            if len(attr_vals[attr_type][sec_type]) != 0:
                axes.scatter(distances[attr_type][sec_type], attr_vals[attr_type][sec_type], color=colors[j],
                             label=sec_type, alpha=0.5, s=10.)
                if maxval is None:
                    maxval = max(attr_vals[attr_type][sec_type])
                else:
                    maxval = max(maxval, max(attr_vals[attr_type][sec_type]))
                if minval is None:
                    minval = min(attr_vals[attr_type][sec_type])
                else:
                    minval = min(minval, min(attr_vals[attr_type][sec_type]))
                xmax0 = max(xmax0, max(distances[attr_type][sec_type]))
                xmin0 = min(xmin0, min(distances[attr_type][sec_type]))
        axes.legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5, fontsize=mpl.rcParams['font.size'])
    xmin = xmin0 - 0.01 * (xmax0 - xmin0)
    xmax = xmax0 + 0.01 * (xmax0 - xmin0)
    for i, attr_type in enumerate(attr_types):
        if len(attr_types) == 1:
            axes = axarr
        else:
            axes = axarr[i]
        axes.set_xlabel('Distance to soma (um)')
        axes.set_xlim(xmin, xmax)
        axes.set_ylabel(ylabel + ' (' + yunits + ')')
        if (maxval is not None) and (minval is not None):
            buffer = 0.01 * (maxval - minval)
            axes.set_ylim(minval - buffer, maxval + buffer)
        if param_label is not None:
            axes.set_title(param_label + ' from ' + attr_type, fontsize=mpl.rcParams['font.size'])
        else:
            axes.set_title('Plot from ' + attr_type, fontsize=mpl.rcParams['font.size'])
        clean_axes(axes)
    if not svg_title is None:
        if param_label is not None:
            svg_title = svg_title + ' - ' + param_label + '.svg'
        else:
            svg_title = svg_title + ' - ' + syn_name + '_' + param_name + ' distribution.svg'
        fig.set_size_inches(5.27, 4.37)
        fig.savefig(data_dir + svg_title, format='svg', transparent=True)
    if show:
        plt.show()
    plt.close()
    if svg_title is not None:
        mpl.rcParams['font.size'] = remember_font_size

    if export is not None:
        if overwrite:
            f = h5py.File(data_dir + '/' + export, 'w')
        else:
            f = h5py.File(data_dir + '/' + export, 'a')
        if 'mech_file_path' in f.attrs:
            if not (f.attrs['mech_file_path'] == '{}'.format(cell.mech_file_path)):
                raise Exception('Specified mechanism filepath {} does not match the mechanism filepath '
                                'of the cell {}'.format(f.attrs['mech_file_path'], cell.mech_file_path))
        else:
            f.attrs['mech_file_path'] = '{}'.format(cell.mech_file_path)
        filetype = 'plot_syn_param'
        if filetype not in f:
            f.create_group(filetype)
        if not f[filetype].attrs.__contains__('mech_attrs'):
            f[filetype].attrs.create('mech_attrs', False)
        if not f[filetype].attrs.__contains__('target_attrs'):
            f[filetype].attrs.create('target_attrs', False)
        if from_mech_attrs and f[filetype].attrs['mech_attrs'] == False:
            f[filetype].attrs['mech_attrs'] = True
        if from_target_attrs and f[filetype].attrs['target_attrs'] == False:
            f[filetype].attrs['target_attrs'] = True
        if len(f[filetype]) == 0:
            session_id = '0'
        else:
            session_id = str(len(f[filetype]))
        f[filetype].create_group(session_id)
        if description is not None:
            f[filetype][session_id].attrs['description'] = description
        f[filetype][session_id].create_group(syn_name)
        f[filetype][session_id][syn_name].create_group(param_name)
        if param_label is not None:
            f[filetype][session_id][syn_name][param_name].attrs['param_label'] = param_label
        f[filetype][session_id][syn_name][param_name].attrs['gid'] = cell.gid
        if svg_title is not None:
            f[filetype][session_id][syn_name][param_name].attrs['svg_title'] = svg_title
        for attr_type in attr_types:
            f[filetype][session_id][syn_name][param_name].create_group(attr_type)
            for sec_type in attr_vals[attr_type]:
                f[filetype][session_id][syn_name][param_name][attr_type].create_group(sec_type)
                f[filetype][session_id][syn_name][param_name][attr_type][sec_type].create_dataset('values',
                                                                                    data=attr_vals[attr_type][sec_type])
                f[filetype][session_id][syn_name][param_name][attr_type][sec_type].create_dataset('distances',
                                                                                    data=distances[attr_type][sec_type])
        f.close()


def plot_syn_attr_from_file(syn_name, param_name, filename, descriptions=None, param_label=None,
                            ylabel='Conductance density', yunits='pS/um2', svg_title=None, data_dir='data'):
    """
    Takes in a list of files, and superimposes plots of distance vs. the provided mechanism parameter for all sec_types
    found in each file.
    :param syn_name: str
    :param param_name: str
    :param filename: str
    :param descriptions: list of str (descriptions of each session). If None, then plot all session_ids
    :param param_label: str
    :param ylabel: str
    :param yunits: str
    :param svg_title: str
    :param data_dir: str (path)
    """
    if svg_title is not None:
        remember_font_size = mpl.rcParams['font.size']
        mpl.rcParams['font.size'] = 20
    markers = mlines.Line2D.filled_markers
    marker_dict = {}
    num_colors = 10
    color_x = np.linspace(0., 1., num_colors)
    colors = [cm.Set1(x) for x in color_x]
    max_param_val, min_param_val = 0., 0.
    max_dist, min_dist = 0.1, 0.
    file_path = data_dir + '/' + filename
    found = False
    if os.path.isfile(file_path):
        with h5py.File(file_path, 'r') as f:
            filetype = 'plot_syn_param'
            if filetype not in f:
                raise Exception('The file {} has the incorrect filetype; it is not plot_syn_param'.format(file))
            attr_types = []
            if f[filetype].attrs['mech_attrs']:
                attr_types.append('mech_attrs')
            if f[filetype].attrs['target_attrs']:
                attr_types.append('target_attrs')
            fig, axarr = plt.subplots(ncols=len(attr_types), sharey=True)
            for s, session_id in enumerate(f[filetype]):
                if f[filetype][session_id].attrs.__contains__('description'):
                    description = f[filetype][session_id].attrs['description']
                    if descriptions is not None and description not in descriptions:
                        continue
                else:
                    description = None
                if syn_name in f[filetype][session_id] and param_name is not None and \
                        param_name in f[filetype][session_id][syn_name]:
                    found = True
                    if param_label is None and 'param_label' in f[filetype][session_id][syn_name][param_name].attrs:
                        param_label = f[filetype][session_id][syn_name][param_name].attrs['param_label']
                    for i, attr_type in enumerate(attr_types):
                        if len(attr_types) == 1:
                            axes = axarr
                        else:
                            axes = axarr[i]
                        if attr_type not in f[filetype][session_id][syn_name][param_name]:
                            continue
                        for j, sec_type in enumerate(f[filetype][session_id][syn_name][param_name][attr_type].keys()):
                            if sec_type not in marker_dict:
                                m = len(marker_dict)
                                marker_dict[sec_type] = markers[m]
                            marker = marker_dict[sec_type]
                            distances = f[filetype][session_id][syn_name][param_name][attr_type][sec_type]['distances'][:]
                            param_vals = f[filetype][session_id][syn_name][param_name][attr_type][sec_type]['values'][:]
                            if description is None:
                                label = sec_type + ' session' + session_id
                            else:
                                label = sec_type + ' ' + description
                            axes.scatter(distances, param_vals, color=colors[s], label=label, alpha=0.25,
                                         marker=marker, s=10.)
                            if max_param_val is None:
                                max_param_val = max(param_vals)
                            else:
                                max_param_val = max(max_param_val, max(param_vals))
                            if min_param_val is None:
                                min_param_val = min(param_vals)
                            else:
                                min_param_val = min(min_param_val, min(param_vals))
                            if max_dist is None:
                                max_dist = max(distances)
                            else:
                                max_dist = max(max_dist, max(distances))
                            if min_dist is None:
                                min_dist = min(distances)
                            else:
                                min_dist = min(min_dist, min(distances))
            if not found:
                raise Exception('Specified synaptic mechanism: %s parameter: %s not found in the provided file: %s' %
                                (syn_name, param_name, file))
            min_dist = min(0., min_dist)
            xmin = min_dist - 0.01 * (max_dist - min_dist)
            xmax = max_dist + 0.01 * (max_dist - min_dist)
            for i, attr_type in enumerate(attr_types):
                if len(attr_types) == 1:
                    axes = axarr
                else:
                    axes = axarr[i]
                axes.legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5,
                            fontsize=mpl.rcParams['font.size'])
                axes.set_xlabel('Distance to soma (um)')
                axes.set_xlim(xmin, xmax)
                axes.set_ylabel(ylabel + ' (' + yunits + ')')
                if (max_param_val is not None) and (min_param_val is not None):
                    buffer = 0.1 * (max_param_val - min_param_val)
                    axes.set_ylim(min_param_val - buffer, max_param_val + buffer)
                if param_label is not None:
                    axes.set_title(param_label + 'from' + attr_types[i], fontsize=mpl.rcParams['font.size'])
                clean_axes(axes)
                axes.tick_params(direction='out')
            if not svg_title is None:
                if param_label is not None:
                    svg_title = svg_title + ' - ' + param_label + '.svg'
                elif param_name is None:
                    svg_title = svg_title + ' - ' + syn_name + '_' + ' distribution.svg'
                else:
                    svg_title = svg_title + ' - ' + syn_name + '_' + param_name + ' distribution.svg'
                fig.set_size_inches(5.27, 4.37)
                fig.savefig(data_dir + svg_title, format='svg', transparent=True)
            plt.show()
            plt.close()
            if svg_title is not None:
                mpl.rcParams['font.size'] = remember_font_size


def plot_mech_param_distribution(cell, mech_name, param_name, export=None, overwrite=False, scale_factor=10000.,
                                 param_label=None, description=None, ylabel='Conductance density', yunits='pS/um2',
                                 svg_title=None, show=True, sec_types=None, data_dir='data'):
    """
    Takes a cell as input rather than a file. No simulation is required, this method just takes a fully specified cell
    and plots the relationship between distance and the specified mechanism parameter for all segments in sections of
    the provided sec_types (defaults to just dendritic sec_types). Used while debugging specification of mechanism
    parameters.
    :param cell: :class:'BiophysCell'
    :param mech_name: str
    :param param_name: str
    :param export: str (name of hdf5 file for export)
    :param overwrite: bool (whether to overwrite or append to potentially existing hdf5 file)
    :param scale_factor: float
    :param param_label: str
    :param description: str
    :param ylabel: str
    :param yunits: str
    :param svg_title: str
    :param show: bool
    :param sec_types: list or str
    :param data_dir: str (path)
    """
    if svg_title is not None:
        remember_font_size = mpl.rcParams['font.size']
        mpl.rcParams['font.size'] = 20
    if sec_types is None or (isinstance(sec_types, str) and sec_types == 'dend'):
        sec_types = ['basal', 'trunk', 'apical', 'tuft']
    elif isinstance(sec_types, str) and sec_types == 'all':
        sec_types = default_ordered_sec_types
    elif not all(sec_type in default_ordered_sec_types for sec_type in sec_types):
        raise ValueError('plot_mech_param_distribution: unrecognized sec_types: %s' % str(sec_types))
    maxval, minval = 1., 0.
    distances = defaultdict(list)
    param_vals = defaultdict(list)
    sec_types_list = [sec_type for sec_type in sec_types if sec_type in cell.nodes and len(cell.nodes[sec_type]) > 0]
    num_colors = 10
    color_x = np.linspace(0., 1., num_colors)
    colors = [cm.Set1(x) for x in color_x]
    for sec_type in sec_types_list:
        if len(cell.nodes[sec_type]) > 0:
            for branch in cell.nodes[sec_type]:
                for seg in [seg for seg in branch.sec if hasattr(seg, mech_name)]:
                    distances[sec_type].append(get_distance_to_node(cell, cell.tree.root, branch, seg.x))
                    if sec_type == 'basal':
                        distances[sec_type][-1] *= -1
                    param_vals[sec_type].append(getattr(getattr(seg, mech_name), param_name) * scale_factor)
    if len(param_vals) == 0 and export is not None:
        print 'Not exporting to %s; mechanism: %s parameter: %s not found in any sec_type' % \
              (export, mech_name, param_name)
        return
    fig, axes = plt.subplots(1)
    max_param_val, min_param_val = 0.1, 0.
    xmax0, xmin0 = 0.1, 0.
    for i, sec_type in enumerate(param_vals):
        axes.scatter(distances[sec_type], param_vals[sec_type], color=colors[i], label=sec_type, alpha=0.5)
        if maxval is None:
            maxval = max(param_vals[sec_type])
        else:
            maxval = max(maxval, max(param_vals[sec_type]))
        if minval is None:
            minval = min(param_vals[sec_type])
        else:
            minval = min(minval, min(param_vals[sec_type]))
        xmax0 = max(xmax0, max(distances[sec_type]))
        xmin0 = min(xmin0, min(distances[sec_type]))
    axes.set_xlabel('Distance to soma (um)')
    xmin = xmin0 - 0.01 * (xmax0 - xmin0)
    xmax = xmax0 + 0.01 * (xmax0 - xmin0)
    axes.set_xlim(xmin, xmax)
    axes.set_ylabel(ylabel + ' (' + yunits + ')')
    if (maxval is not None) and (minval is not None):
        buffer = 0.01 * (maxval - minval)
        axes.set_ylim(minval - buffer, maxval + buffer)
    if param_label is not None:
        axes.set_title(param_label, fontsize=mpl.rcParams['font.size'])
    axes.legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5, fontsize=mpl.rcParams['font.size'])
    clean_axes(axes)

    if svg_title is not None:
        if param_label is not None:
            svg_title = svg_title + ' - ' + param_label + '.svg'
        else:
            svg_title = svg_title + ' - ' + mech_name + '_' + param_name + ' distribution.svg'
        fig.set_size_inches(5.27, 4.37)
        fig.savefig(data_dir + svg_title, format='svg', transparent=True)
    if show:
        plt.show()
    plt.close()
    if svg_title is not None:
        mpl.rcParams['font.size'] = remember_font_size

    if export is not None:
        if overwrite:
            f = h5py.File(data_dir + '/' + export, 'w')
        else:
            f = h5py.File(data_dir + '/' + export, 'a')
        if 'mech_file_path' in f.attrs.keys():
            if cell.mech_file_path is None or not f.attrs['mech_file_path'] == cell.mech_file_path:
                raise ValueError('plot_mech_param_distribution: provided mech_file_path: %s does not match the '
                                'mech_file_path of %s cell %i: %s' %
                                (f.attrs['mech_file_path'], cell.pop_name, cell.gid, cell.mech_file_path))
        elif cell.mech_file_path is not None:
            f.attrs['mech_file_path'] = cell.mech_file_path
        filetype = 'plot_mech_param'
        if filetype not in f:
            f.create_group(filetype)
        if len(f[filetype]) == 0:
            session_id = '0'
        else:
            session_id = str(len(f[filetype]))
        f[filetype].create_group(session_id)
        if description is not None:
            f[filetype][session_id].attrs['description'] = description
        f[filetype][session_id].create_group(mech_name)
        f[filetype][session_id][mech_name].create_group(param_name)
        if param_label is not None:
            f[filetype][session_id][mech_name][param_name].attrs['param_label'] = param_label
        f[filetype][session_id][mech_name][param_name].attrs['gid'] = cell.gid
        if svg_title is not None:
            f[filetype][session_id][mech_name][param_name].attrs['svg_title'] = svg_title
        for sec_type in param_vals:
            f[filetype][session_id][mech_name][param_name].create_group(sec_type)
            f[filetype][session_id][mech_name][param_name][sec_type].create_dataset('values',
                                                                                    data=param_vals[sec_type])
            f[filetype][session_id][mech_name][param_name][sec_type].create_dataset('distances',
                                                                                    data=distances[sec_type])
        f.close()


def plot_cable_param_distribution(cell, mech_name, export=None, overwrite=False, scale_factor=1., param_label=None,
                                  description=None, ylabel='Specific capacitance', yunits='uF/cm2', svg_title=None,
                                  show=True, data_dir='data', sec_types=None):
    """
    Takes a cell as input rather than a file. No simulation is required, this method just takes a fully specified cell
    and plots the relationship between distance and the specified mechanism parameter for all dendritic segments. Used
    while debugging specification of mechanism parameters.
    :param cell: :class:'BiophysCell'
    :param mech_name: str
    :param param_name: str
    :param export: str (name of hdf5 file for export)
    :param overwrite: bool (whether to overwrite or append to potentially existing hdf5 file)
    :param scale_factor: float
    :param param_label: str
    :param ylabel: str
    :param yunits: str
    :param svg_title: str
    :param data_dir: str (path)
    :param sec_types: list of str
    """
    if svg_title is not None:
        remember_font_size = mpl.rcParams['font.size']
        mpl.rcParams['font.size'] = 20
    if sec_types is None or (isinstance(sec_types, str) and sec_types == 'dend'):
        sec_types = ['basal', 'trunk', 'apical', 'tuft']
    elif isinstance(sec_types, str) and sec_types == 'all':
        sec_types = default_ordered_sec_types
    elif not all(sec_type in default_ordered_sec_types for sec_type in sec_types):
        raise ValueError('plot_synaptic_attribute_distribution: unrecognized sec_types: %s' % str(sec_types))
    sec_types_list = [sec_type for sec_type in sec_types if sec_type in cell.nodes and len(cell.nodes[sec_type]) > 0]
    fig, axes = plt.subplots(1)
    maxval, minval = 1., 0.
    distances = defaultdict(list)
    param_vals = defaultdict(list)
    num_colors = len(sec_types_list)
    color_x = np.linspace(0., 1., num_colors)
    colors = [cm.Set1(x) for x in color_x]
    for sec_type in sec_types_list:
        if len(cell.nodes[sec_type]) > 0:
            for branch in cell.nodes[sec_type]:
                if mech_name == 'Ra':
                    distances[sec_type].append(get_distance_to_node(cell, cell.tree.root, branch))
                    if sec_type == 'basal':
                        distances[sec_type][-1] *= -1
                    param_vals[sec_type].append(getattr(branch.sec, mech_name) * scale_factor)
                else:
                    for seg in [seg for seg in branch.sec if hasattr(seg, mech_name)]:
                        distances[sec_type].append(get_distance_to_node(cell, cell.tree.root, branch, seg.x))
                        if sec_type == 'basal':
                            distances[sec_type][-1] *= -1
                        param_vals[sec_type].append(getattr(seg, mech_name) * scale_factor)
    xmax0 = 0.1
    xmin0 = 0.
    for i, sec_type in enumerate(param_vals):
        axes.scatter(distances[sec_type], param_vals[sec_type], color=colors[i], label=sec_type, alpha=0.5)
        if maxval is None:
            maxval = max(param_vals[sec_type])
        else:
            maxval = max(maxval, max(param_vals[sec_type]))
        if minval is None:
            minval = min(param_vals[sec_type])
        else:
            minval = min(minval, min(param_vals[sec_type]))
        xmax0 = max(xmax0, max(distances[sec_type]))
        xmin0 = min(xmin0, min(distances[sec_type]))
    axes.set_xlabel('Distance to soma (um)')
    xmin = xmin0 - 0.01 * (xmax0 - xmin0)
    xmax = xmax0 + 0.01 * (xmax0 - xmin0)
    axes.set_xlim(xmin, xmax)
    axes.set_ylabel(ylabel + ' (' + yunits + ')')
    if (maxval is not None) and (minval is not None):
        buffer = 0.01 * (maxval - minval)
        axes.set_ylim(minval - buffer, maxval + buffer)
    if param_label is not None:
        axes.set_title(param_label, fontsize=mpl.rcParams['font.size'])
    axes.legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5, fontsize=mpl.rcParams['font.size'])
    clean_axes(axes)
    axes.tick_params(direction='out')
    if svg_title is not None:
        if param_label is not None:
            svg_title = svg_title + ' - ' + param_label + '.svg'
        else:
            svg_title = svg_title + ' - ' + mech_name + '_' + ' distribution.svg'
        fig.set_size_inches(5.27, 4.37)
        fig.savefig(data_dir + svg_title, format='svg', transparent=True)
    if show:
        plt.show()
    plt.close()
    if svg_title is not None:
        mpl.rcParams['font.size'] = remember_font_size

    if export is not None:
        if overwrite:
            f = h5py.File(data_dir + '/' + export, 'w')
        else:
            f = h5py.File(data_dir + '/' + export, 'a')
        if 'mech_file_path' in f.attrs.keys():
            if not (f.attrs['mech_file_path'] == '{}'.format(cell.mech_file_path)):
                raise Exception('Specified mechanism filepath {} does not match the mechanism filepath '
                                'of the cell {}'.format(f.attrs['mech_file_path'], cell.mech_file_path))
        else:
            f.attrs['mech_file_path'] = '{}'.format(cell.mech_file_path)
        filetype = 'plot_mech_param'
        if filetype not in f:
            f.create_group(filetype)
        if len(f[filetype]) == 0:
            session_id = '0'
        else:
            session_id = str(len(f[filetype]))
        f[filetype].create_group(session_id)
        if description is not None:
            f[filetype][session_id].attrs['description'] = description
        f[filetype][session_id].create_group(mech_name)
        if param_label is not None:
            f[filetype][session_id][mech_name].attrs['param_label'] = param_label
        f[filetype][session_id][mech_name].attrs['gid'] = cell.gid
        if svg_title is not None:
            f[filetype][session_id][mech_name].attrs['svg_title'] = svg_title
        for sec_type in param_vals:
            f[filetype][session_id][mech_name].create_group(sec_type)
            f[filetype][session_id][mech_name][sec_type].create_dataset('values', data=param_vals[sec_type])
            f[filetype][session_id][mech_name][sec_type].create_dataset('distances', data=distances[sec_type])
        f.close()


def plot_mech_param_from_file(mech_name, param_name, filename, descriptions=None, param_label=None,
                              ylabel='Conductance density', yunits='pS/um2', svg_title=None, data_dir='data'):
    """
    Takes in a list of files, and superimposes plots of distance vs. the provided mechanism parameter for all sec_types
    found in each file.
    :param mech_name: str
    :param param_name: str
    :param filename: str (hdf filename)
    :param descriptions: list of str (descriptions of each session). If None, then plot all session_ids
    :param param_label: str
    :param ylabel: str
    :param yunits: str
    :param svg_title: str
    :param data_dir: str (path)
    """
    if svg_title is not None:
        remember_font_size = mpl.rcParams['font.size']
        mpl.rcParams['font.size'] = 20
    fig, axes = plt.subplots(1)
    max_param_val, min_param_val = 0., 0.
    max_dist, min_dist = 0., 0.
    num_colors = 10
    markers = mlines.Line2D.filled_markers
    color_x = np.linspace(0., 1., num_colors)
    colors = [cm.Set1(x) for x in color_x]
    marker_dict = {}
    file_path = data_dir + '/' + filename
    found = False
    if os.path.isfile(file_path):
        with h5py.File(file_path, 'r') as f:
            filetype = 'plot_mech_param'
            if filetype not in f:
                raise Exception('The file {} has the incorrect filetype; it is not plot_mech_param'.format(file))
            for s, session_id in enumerate(f[filetype]):
                if f[filetype][session_id].attrs.__contains__('description'):
                    description = f[filetype][session_id].attrs['description']
                    if descriptions is not None and description not in descriptions:
                        continue
                else:
                    description = None
                if mech_name in f[filetype][session_id] and \
                        (param_name is None or param_name in f[filetype][session_id][mech_name]):
                    found = True
                    if param_name is None:
                        if param_label is None and 'param_label' in f[filetype][session_id][mech_name].attrs:
                            param_label = f[filetype][session_id][mech_name].attrs['param_label']
                        group = f[filetype][session_id][mech_name]
                    else:
                        if param_label is None and \
                                'param_label' in f[filetype][session_id][mech_name][param_name].attrs:
                            param_label = f[filetype][session_id][mech_name][param_name].attrs['param_label']
                        group = f[filetype][session_id][mech_name][param_name]
                    for j, sec_type in enumerate(group):
                        if sec_type not in marker_dict:
                            m = len(marker_dict)
                            marker_dict[sec_type] = markers[m]
                        marker = marker_dict[sec_type]
                        param_vals = group[sec_type]['values'][:]
                        distances = group[sec_type]['distances'][:]
                        if description is None:
                            label = sec_type + ' session ' + session_id
                        else:
                            label = sec_type + ' ' + description
                        axes.scatter(distances, param_vals, color=colors[s], label=label, alpha=0.5, marker=marker)
                        if max_param_val is None:
                            max_param_val = max(param_vals)
                        else:
                            max_param_val = max(max_param_val, max(param_vals))
                        if min_param_val is None:
                            min_param_val = min(param_vals)
                        else:
                            min_param_val = min(min_param_val, min(param_vals))
                        if max_dist is None:
                            max_dist = max(distances)
                        else:
                            max_dist = max(max_dist, max(distances))
                        if min_dist is None:
                            min_dist = min(distances)
                        else:
                            min_dist = min(min_dist, min(distances))
    if not found:
        raise Exception('Specified mechanism: %s parameter: %s not found in the provided file: %s' %
                        (mech_name, param_name, file))
    axes.set_xlabel('Distance to soma (um)')
    min_dist = min(0., min_dist)
    xmin = min_dist - 0.01 * (max_dist - min_dist)
    xmax = max_dist + 0.01 * (max_dist - min_dist)
    axes.set_xlim(xmin, xmax)
    axes.set_ylabel(ylabel + ' (' + yunits + ')')
    if (max_param_val is not None) and (min_param_val is not None):
        buffer = 0.1 * (max_param_val - min_param_val)
    axes.set_ylim(min_param_val - buffer, max_param_val + buffer)
    if param_label is not None:
        axes.set_title(param_label, fontsize=mpl.rcParams['font.size'])
    axes.legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5, fontsize=mpl.rcParams['font.size'])
    clean_axes(axes)
    axes.tick_params(direction='out')
    if not svg_title is None:
        if param_label is not None:
            svg_title = svg_title + ' - ' + param_label + '.svg'
        elif param_name is None:
            svg_title = svg_title + ' - ' + mech_name + '_' + ' distribution.svg'
        else:
            svg_title = svg_title + ' - ' + mech_name + '_' + param_name + ' distribution.svg'
        fig.set_size_inches(5.27, 4.37)
        fig.savefig(data_dir + svg_title, format='svg', transparent=True)
    plt.show()
    plt.close()
    if svg_title is not None:
        mpl.rcParams['font.size'] = remember_font_size


def plot_sum_mech_param_distribution(cell, mech_param_list, scale_factor=10000., param_label=None,
                                 ylabel='Conductance density', yunits='pS/um2', svg_title=None):
    """
    Takes a cell as input rather than a file. No simulation is required, this method just takes a fully specified cell
    and plots the relationship between distance and the specified mechanism parameter for all dendritic segments. Used
    while debugging specification of mechanism parameters.
    :param cell: :class:'HocCell'
    :param mech_param_list: list of tuple of str
    :param scale_factor: float
    :param ylabel: str
    :param yunits: str
    :param svg_title: str
    """
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    dend_types = ['basal', 'trunk', 'apical', 'tuft']

    if svg_title is not None:
        remember_font_size = mpl.rcParams['font.size']
        mpl.rcParams['font.size'] = 20
    fig, axes = plt.subplots(1)
    for i, sec_type in enumerate(dend_types):
        distances = []
        param_vals = []
        for branch in cell.get_nodes_of_subtype(sec_type):
            for seg in branch.sec:
                this_param_val = 0.
                this_distance = None
                for mech_name, param_name in mech_param_list:
                    if hasattr(seg, mech_name):
                        if this_distance is None:
                            this_distance = cell.get_distance_to_node(cell.tree.root, branch, seg.x)
                            if sec_type == 'basal':
                                this_distance *= -1
                        this_param_val += getattr(getattr(seg, mech_name), param_name) * scale_factor
                if this_distance is not None:
                    distances.append(this_distance)
                    param_vals.append(this_param_val)
        if param_vals:
            axes.scatter(distances, param_vals, color=colors[i], label=sec_type)
            if maxval is None:
                maxval = max(param_vals)
            else:
                maxval = max(maxval, max(param_vals))
            if minval is None:
                minval = min(param_vals)
            else:
                minval = min(minval, min(param_vals))
    axes.set_xlabel('Distance to soma (um)')
    axes.set_xlim(-200., 525.)
    axes.set_xticks([-150., 0., 150., 300., 450.])
    axes.set_ylabel(ylabel+' ('+yunits+')')
    buffer = 0.1 * (maxval - minval)
    axes.set_ylim(minval-buffer, maxval+buffer)
    if param_label is not None:
        plt.title(param_label, fontsize=mpl.rcParams['font.size'])
    plt.legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5, fontsize=mpl.rcParams['font.size'])
    clean_axes(axes)
    axes.tick_params(direction='out')
    if not svg_title is None:
        if param_label is not None:
            svg_title = svg_title+' - '+param_label+'.svg'
        else:
            mech_name, param_name = mech_param_list[0]
            svg_title = svg_title+' - '+mech_name+'_'+param_name+' distribution.svg'
        fig.set_size_inches(5.27, 4.37)
        fig.savefig(data_dir + svg_title, format='svg', transparent=True)
    plt.show()
    plt.close()
    if svg_title is not None:
        mpl.rcParams['font.size'] = remember_font_size


def plot_absolute_energy(storage):
    fig, axes = plt.subplots(1)
    colors = list(cm.rainbow(np.linspace(0, 1, len(storage.history))))
    this_attr = 'objectives'
    for j, population in enumerate(storage.history):
        axes.scatter([indiv.rank for indiv in population],
                    [np.sum(getattr(indiv, this_attr)) for indiv in population],
                    c=colors[j], alpha=0.05)
        axes.scatter([indiv.rank for indiv in storage.survivors[j]],
                    [np.sum(getattr(indiv, this_attr)) for indiv in storage.survivors[j]], c=colors[j], alpha=0.5)
    axes.set_xlabel('Rank')
    axes.set_ylabel('Summed Objectives')


def plot_best_norm_features_boxplot(storage, target_val, target_range):
    """

    :return:
    """
    #Ensure that f_I_slope is in target_val with a value of 53.
    fig, axes = plt.subplots(1)
    labels = target_val.keys()
    # y_values = range(len(y_labels))
    final_survivors = storage.survivors[-1]
    norm_feature_vals = {}
    colors = list(cm.rainbow(np.linspace(0, 1, len(labels))))
    for survivor in final_survivors:
        for i, feature in enumerate(storage.feature_names):
            if feature in target_val:
                if feature not in norm_feature_vals:
                    norm_feature_vals[feature] = []
                if (feature == 'slow_depo' and getattr(survivor, 'features')[i] < target_val[feature]) or \
                        (feature == 'AHP' and getattr(survivor, 'features')[i] < target_val[feature]):
                    normalized_val = 0.
                else:
                    normalized_val = (getattr(survivor, 'features')[i] - target_val[feature]) / target_range[feature]
                norm_feature_vals[feature].append(normalized_val)
    x_values_list = [norm_feature_vals[feature] for feature in labels]
    """
    for i, y_value in enumerate(y_values):
        axes.scatter(x_values_list[i], y_value * np.ones(len(x_values_list[i])), c=colors[i])
    """
    bplot = axes.boxplot(x_values_list, vert=False, labels=labels, patch_artist=True)
    colors = list(cm.rainbow(np.linspace(0, 1, len(labels))))
    for patch, color in zip(bplot['boxes'], colors):
        patch.set_facecolor(color)
    axes.set_xlabel('Normalized Features')
    #axes.set_yticks(y_values)
    #axes.set_yticklabels(y_labels)
    axes.set_title('Best Parameter Sets')
    clean_axes(axes)
    fig.tight_layout()
    plt.show()
    plt.close()


def plot_best_norm_features_scatter(storage, target_val, target_range):
    """

    :return:
    """
    #Ensure that f_I_slope is in target_val with a value of 53.
    """
    {'ADP': 2.0, 'AHP': 0.8, 'ais_delay': 0.02, 'dend R_inp': 75.0, 'dend_amp': 0.06, 'rebound_firing': 0.2,
     'slow_depo': 2.0, 'soma R_inp': 59.0, 'soma_peak': 8.0, 'spont_firing': 0.2, 'v_th': -9.600000000000001,
     'vm_stability': 2.0, 'f_I_slope': 10.6}
    """
    orig_fontsize = mpl.rcParams['font.size']
    mpl.rcParams['font.size'] = 16.
    fig, axes = plt.subplots(1)
    y_labels = target_val.keys()
    y_values = range(len(y_labels))
    final_survivors = storage.survivors[-1]
    norm_feature_vals = {}
    colors = list(cm.rainbow(np.linspace(0, 1, len(y_labels))))
    for survivor in final_survivors:
        for i, feature in enumerate(storage.feature_names):
            if feature in target_val:
                if feature not in norm_feature_vals:
                    norm_feature_vals[feature] = []
                if (feature == 'slow_depo' and getattr(survivor, 'features')[i] < target_val[feature]) or \
                        (feature == 'AHP' and getattr(survivor, 'features')[i] < target_val[feature]):
                    normalized_val = 0.
                else:
                    normalized_val = (getattr(survivor, 'features')[i] - target_val[feature]) / target_range[feature]
                norm_feature_vals[feature].append(normalized_val)
    x_values_list = [norm_feature_vals[feature] for feature in y_labels]
    for i, y_value in enumerate(y_values):
        axes.scatter(x_values_list[i], y_value * np.ones(len(x_values_list[i])), c=colors[i], alpha=0.4)
    axes.set_xlabel('Normalized Features')
    axes.set_xlim(-2.5, 2.5)
    axes.set_yticks(y_values)
    axes.set_yticklabels(y_labels)
    axes.set_title('Best Parameter Sets', fontsize=mpl.rcParams['font.size'] + 2)
    clean_axes(axes)
    fig.tight_layout()
    plt.show()
    plt.close()
    mpl.rcParams['font.size'] = orig_fontsize


def plot_exported_f_I(file_path, group_name='f_I'):
    """

    :param file_path: str (path)
    :param group_name: str
    """
    orig_fontsize = mpl.rcParams['font.size']
    # mpl.rcParams['font.size'] = 20.
    if not os.path.isfile(file_path):
        raise IOError('plot_exported_f_I: invalid file path: %s' % file_path)
    with h5py.File(file_path, 'r') as f:
        if group_name not in f:
            raise AttributeError('plot_exported_f_I: provided file path: %s does not contain required top-level group '
                                 'with name: %s' % (file_path, group_name))
        group = f[group_name]
        fig, axes = plt.subplots(1, 2)
        i_amp = group['i_amp']
        rate = group['rate']
        exp_rate = group['exp_rate']
        adi = group['adi']
        exp_adi = group['exp_adi']
        spike_num = range(3, len(adi) + 3)
        axes[0].scatter(spike_num, adi, label='Simulation', c='r', linewidth=0, alpha=0.5)
        axes[0].scatter(spike_num, exp_adi[:len(adi)], label='Experiment', c='grey', linewidth=0, alpha=0.5)
        axes[0].legend(loc='best', frameon=False, framealpha=0.5)
        axes[0].set_xlabel('Spike number in train')
        axes[0].set_ylabel('Adaptation index')
        axes[0].set_title('Spike rate adaptation', fontsize=mpl.rcParams['font.size'])
        axes[1].scatter(i_amp, rate, label='Simulation', c='r', linewidth=0, alpha=0.5)
        axes[1].scatter(i_amp, exp_rate, label='Experiment', c='grey', linewidth=0, alpha=0.5)
        axes[1].legend(loc='best', frameon=False, framealpha=0.5)
        axes[1].set_xlabel('Current injection amp (nA)')
        axes[1].set_ylabel('Firing Rate (Hz)')
        axes[1].set_title('f-I', fontsize=mpl.rcParams['font.size'])
    clean_axes(axes)
    fig.tight_layout()
    fig.show()
    mpl.rcParams['font.size'] = orig_fontsize


def plot_sim_from_file(file_path, group_name='sim_output'):
    """

    :param file_path: str (path)
    :param group_name: str
    """
    orig_fontsize = mpl.rcParams['font.size']
    # mpl.rcParams['font.size'] = 20.
    if not os.path.isfile(file_path):
        raise IOError('plot_sim_from_file: invalid file path: %s' % file_path)
    with h5py.File(file_path, 'r') as f:
        if group_name not in f:
            raise AttributeError('plot_sim_from_file: provided file path: %s does not contain required top-level group '
                                 'with name: %s' % (file_path, group_name))
        for trial in f[group_name].itervalues():
            fig, axes = plt.subplots()
            for name, rec in trial['recs'].iteritems():
                description = str(rec.attrs['description'])
                node_name = '%s%i' % (rec.attrs['type'], rec.attrs['index'])
                label = '%s: %s(%.2f) %s' % (name, node_name, rec.attrs['loc'], description)
                axes.plot(trial['time'], rec, label=label)
                axes.set_xlabel('Time (ms)')
                axes.set_ylabel('%s (%s)' % (rec.attrs['ylabel'], rec.attrs['units']))
            axes.legend(loc='best', frameon=False, framealpha=0.5)
            title = None
            if 'title' in trial.attrs:
                title = trial.attrs['title']
            if 'description' in trial.attrs:
                if title is not None:
                    title = title + '; ' + trial.attrs['description']
                else:
                    title = trial.attrs['description']
            if title is not None:
                axes.set_title(title, fontsize=mpl.rcParams['font.size'])
            clean_axes(axes)
            fig.tight_layout()
            fig.show()
    mpl.rcParams['font.size'] = orig_fontsize


def plot_na_gradient_params(x_dict):
    """

    :param x_dict: dict
    :return:
    """
    orig_fontsize = mpl.rcParams['font.size']
    mpl.rcParams['font.size'] = 20.
    fig, axes = plt.subplots(1)
    x_labels = ['axon', 'AIS', 'soma', 'dend']
    x_values = range(len(x_labels))
    colors = ['b', 'c', 'g', 'r']
    y_values = [x_dict['axon.gbar_nax'], x_dict['ais.gbar_nax'], x_dict['soma.gbar_nas'], x_dict['dend.gbar_nas']]
    for i in x_values:
        axes.scatter(x_values[i], y_values[i], c=colors[i])
    # axes.set_ylim(-2.5, 2.5)
    axes.set_xticks(x_values)
    axes.set_xticklabels(x_labels)
    axes.set_ylabel('gmax_na')
    clean_axes(axes)
    fig.tight_layout()
    plt.show()
    plt.close()
    mpl.rcParams['font.size'] = orig_fontsize

