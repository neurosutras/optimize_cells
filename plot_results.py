__author__ = 'milsteina'
from optimize_cells_utils import *
import matplotlib as mpl
import matplotlib.lines as mlines
import scipy.stats as stats
import matplotlib.gridspec as gridspec
from matplotlib import cm
from dentate.cells import *

mpl.rcParams['svg.fonttype'] = 'none'
mpl.rcParams['font.size'] = 12.
# mpl.rcParams['font.size'] = 14.
#mpl.rcParams['font.sans-serif'] = 'Arial'
#mpl.rcParams['font.sans-serif'] = 'Calibri'
mpl.rcParams['font.sans-serif'] = 'Myriad Pro'
mpl.rcParams['text.usetex'] = False
#mpl.rcParams['figure.figsize'] = 6, 4.3
"""
mpl.rcParams['axes.labelsize'] = 'larger'
mpl.rcParams['axes.titlesize'] = 'xx-large'
mpl.rcParams['xtick.labelsize'] = 'large'
mpl.rcParams['ytick.labelsize'] = 'large'
mpl.rcParams['legend.fontsize'] = 'x-large'
"""


def plot_Rinp(rec_file_list, sec_types_list=None, features_list=None, features_labels=None, file_labels=None,
              data_dir='data/'):
    """
    Expects each file in list to be generated by parallel_rinp.
    Superimpose features across cells recorded from simulated step current injections to probe input resistance and
    membrane time constant.
    :return:
    """
    orig_fontsize = mpl.rcParams['font.size']
    mpl.rcParams['font.size'] = 18.
    if isinstance(rec_file_list, str):
        rec_file_list = [rec_file_list]
    if isinstance(sec_types_list, str):
        sec_types_list = [sec_types_list]
    if isinstance(features_list, str):
        features_list = [features_list]
    if isinstance(features_labels, str):
        features_labels = [features_labels]
    if isinstance(file_labels, str):
        file_labels = [file_labels]
    if sec_types_list is None:
        sec_types_list = ['axon', 'apical', 'soma']
    axon_types_list = ['axon', 'ais', 'axon_hill']
    dend_types_list = ['basal', 'apical', 'trunk', 'tuft']
    if features_list is None:
        features_list = ['Rinp_peak', 'Rinp_baseline', 'Rinp_steady', 'decay_90']
    if features_labels is None:
        features_labels_default_dict = {'Rinp_peak': 'Input resistance - peak (MOhm)', 'Rinp_baseline': 'Baseline Vm (mV)',
                                'Rinp_steady': 'Input resistance - steady-state (MOhm)',
                                'decay_90': 'Membrane time constant (ms)'}
        features_labels_dict = {}
        for feature in features_list:
            if feature in features_labels_default_dict:
                features_labels_dict[feature] = features_labels_default_dict[feature]
            else:
                features_labels_dict[feature] = feature
    else:
        features_labels_dict = {feature: label for (feature, label) in zip(features_list, features_labels)}
    ax_list = []
    for file_index, rec_file in enumerate(rec_file_list):
        feature_dict = {feature: {} for feature in features_list}
        distances_dict = {feature: {} for feature in features_list}
        with h5py.File(data_dir + rec_file + '.hdf5', 'r') as f:
            for item in f['Rinp_data'].itervalues():
                if ((item.attrs['type'] in sec_types_list) or
                        ('axon' in sec_types_list and item.attrs['type'] in axon_types_list) or
                        ('dendrite' in sec_types_list and item.attrs['type'] in dend_types_list)):
                    if 'axon' in sec_types_list and item.attrs['type'] in axon_types_list:
                        sec_type = 'axon'
                    elif 'dendrite' in sec_types_list and item.attrs['type'] in dend_types_list:
                        sec_type = 'dendrite'
                    else:
                        sec_type = item.attrs['type']
                    for feature in features_list:
                        if sec_type not in distances_dict[feature].keys():
                            distances_dict[feature][sec_type] = []
                        if item.attrs['type'] in ['basal', 'axon', 'ais', 'axon_hill']:
                            distances_dict[feature][sec_type].append(item.attrs['soma_distance'] * -1.)
                        else:
                            distances_dict[feature][sec_type].append(item.attrs['soma_distance'])
                        if sec_type not in feature_dict[feature].keys():
                            feature_dict[feature][sec_type] = []
                        feature_dict[feature][sec_type].append(item.attrs[feature])
        num_colors = 10
        color_x = np.linspace(0., 1., num_colors)
        colors = [cm.Set1(x) for x in color_x]
        for index, feature in enumerate(features_list):
            if len(ax_list) <= index:
                fig, ax = plt.subplots(1)
                ax_list.append(ax)
            for i, sec_type in enumerate(sec_types_list):
                if file_labels is None:
                    label = sec_type
                elif len(sec_types_list) == 1:
                    label = file_labels[file_index]
                else:
                    label = file_labels[file_index] + ': ' + sec_type
                ax_list[index].scatter(distances_dict[feature][sec_type], feature_dict[feature][sec_type],
                            label=label, color = colors[file_index*len(sec_types_list) + i], alpha=0.5)
            ax_list[index].set_xlabel('Distance to soma')
            ax_list[index].set_ylabel(features_labels_dict[feature])
            ax_list[index].legend(loc='best', scatterpoints = 1, frameon=False, framealpha=0.5)
            clean_axes(ax_list[index])
    plt.show()
    plt.close()
    mpl.rcParams['font.size'] = orig_fontsize


def plot_Rinp_curr_inj(rec_file, rec_num):
    """

    :param rec_file: str
    :return:
    """
    with h5py.File(data_dir + rec_file + '.hdf5', 'r') as f:
        y_vals = f[str(rec_num)]['stim']['0'][:]
        x_vals = f[str(rec_num)]['time']
        fig, axes = plt.subplots(1)
        #axes.scatter(x_vals, y_vals)
        axes.plot(x_vals, y_vals)
        axes.set_xlabel('Time (ms')
        axes.set_ylabel('Injected current (nA)')
        clean_axes(axes)
        fig.tight_layout()
    plt.show()
    plt.close()


def plot_Rinp_avg_waves(rec_file_list, sec_types_list=None, file_labels=None):
    """
    Expects each file in list to be generated by parallel_rinp.
    avg_waves contains voltage waves averaged across similar sec_types (dendritic sections are divided into proximal
    and distal) recorded from simulated step current injections to probe input resistance and membrane time constant.
    :param rec_file_list: str or list of str
    :param sec_types_list:  str or list of str
    :param file_labels:  str or list of str
    """
    orig_fontsize = mpl.rcParams['font.size']
    mpl.rcParams['font.size'] = 18.
    if isinstance(rec_file_list, str):
        rec_file_list = [rec_file_list]
    if isinstance(sec_types_list, str):
        sec_types_list = [sec_types_list]
    if isinstance(file_labels, str):
        file_labels = [file_labels]
    if sec_types_list is None:
        sec_types_list = ['soma', 'prox_apical', 'dist_apical']
    num_colors = 10
    color_x = np.linspace(0., 1., num_colors)
    colors = [cm.Set1(x) for x in color_x]
    ax_list = []
    for i, item in enumerate(sec_types_list):
        if len(ax_list) <= i:
            fig, ax = plt.subplots(1)
            ax_list.append(ax)
        for file_index, rec_file in enumerate(rec_file_list):
            with h5py.File(data_dir + rec_file + '.hdf5', 'r') as f:
                if item in f['avg_waves']:
                    if file_labels is not None:
                        label = file_labels[file_index]
                        ax_list[i].plot(f['avg_waves']['time'], f['avg_waves'][item], label=label,
                                        color=colors[file_index])
                    else:
                        ax_list[i].plot(f['avg_waves']['time'], f['avg_waves'][item], color=colors[file_index])
                ax_list[i].set_xlabel('Time (ms)')
                ax_list[i].set_ylabel('Voltage (mV)')
                if file_labels is not None:
                    ax_list[i].legend(loc='best', scatterpoints = 1, frameon=False, framealpha=0.5)
                ax_list[i].set_title(item)
                clean_axes(ax_list[i])
    plt.show()
    plt.close()
    mpl.rcParams['font.size'] = orig_fontsize


def plot_superimpose_conditions(rec_filename, legend=False):
    """
    File contains simulation results from iterating through some changes in parameters or stimulation conditions.
    This function produces one plot per recorded vector. Each plot superimposes the recordings from each of the
    simulation iterations.
    :param rec_filename: str
    :param legend: bool
    """
    f = h5py.File(data_dir+rec_filename+'.hdf5', 'r')
    rec_ids = []
    sim_ids = []
    for sim in f.itervalues():
        if 'description' in sim.attrs and not sim.attrs['description'] in sim_ids:
            sim_ids.append(sim.attrs['description'])
        for rec in sim['rec'].itervalues():
            if 'description' in rec.attrs:
                rec_id = rec.attrs['description']
            else:
                rec_id = rec.attrs['type']+str(rec.attrs['index'])
            if not rec_id in (id['id'] for id in rec_ids):
                rec_ids.append({'id': rec_id, 'ylabel': rec.attrs['ylabel']+' ('+rec.attrs['units']+')'})
    fig, axes = plt.subplots(1, max(2, len(rec_ids)))
    for i in range(len(rec_ids)):
        axes[i].set_xlabel('Time (ms)')
        axes[i].set_ylabel(rec_ids[i]['ylabel'])
        axes[i].set_title(rec_ids[i]['id'])
    for sim in f.itervalues():
        if 'description' in sim.attrs:
            sim_id = sim.attrs['description']
        else:
            sim_id = ''
        tvec = sim['time']
        for rec in sim['rec'].itervalues():
            if ('description' in rec.attrs):
                rec_id = rec.attrs['description']
            else:
                rec_id = rec.attrs['type']+str(rec.attrs['index'])
            i = [index for index, id in enumerate(rec_ids) if id['id'] == rec_id][0]
            axes[i].plot(tvec[:], rec[:], label=sim_id)
    if legend:
        for i in range(len(rec_ids)):
            axes[i].legend(loc='best', framealpha=0.5, frameon=False)
    plt.subplots_adjust(hspace=0.4, wspace=0.3, left=0.05, right=0.95, top=0.95, bottom=0.1)
    plt.show()
    plt.close()
    f.close()


def plot_synaptic_parameter(rec_file_list, description_list=None):
    """
    Expects each file in list to be generated by optimize_EPSP_amp.
    Files contain one group for each type of dendritic section. Groups contain distances from soma and values for all
    measured synaptic parameters. Produces one column of plots per sec_type, one row of plots per parameter, and
    superimposes data from each rec_file.
    :param rec_file_list: list of str
    :param description_list: list of str
    """
    if not type(rec_file_list) == list:
        rec_file_list = [rec_file_list]
    if description_list is None:
        description_list = [" " for rec in rec_file_list]
    with h5py.File(data_dir+rec_file_list[0]+'.hdf5', 'r') as f:
        param_list = [dataset for dataset in f.itervalues().next() if not dataset == 'distances']
        fig, axes = plt.subplots(max(2,len(param_list)), max(2, len(f)))
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    for index, rec_filename in enumerate(rec_file_list):
        with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as f:
            for i, sec_type in enumerate(f):
                for j, dataset in enumerate(param_list):
                    axes[j][i].scatter(f[sec_type]['distances'][:], f[sec_type][dataset][:],
                                       label=description_list[index], color=colors[index])
                    axes[j][i].set_title(sec_type+' synapses')
                    axes[j][i].set_xlabel('Distance to soma (um)')
                    axes[j][i].set_ylabel(f.attrs['syn_type']+': '+dataset+'\n'+f.attrs[dataset])
    plt.legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5)
    plt.subplots_adjust(hspace=0.4, wspace=0.3, left=0.09, right=0.98, top=0.95, bottom=0.05)
    plt.show()
    plt.close()


def plot_synaptic_parameter_GC(rec_file_list, param_names=None, description_list=None):
    """
    Expects each file in list to be generated by optimize_EPSP_amp.
    Files contain one group for each type of dendritic section. Groups contain distances from soma and values for all
    measured synaptic parameters. Produces one column of plots per sec_type, one row of plots per parameter, and
    superimposes data from each rec_file.
    :param rec_file_list: list of str
    :param description_list: list of str
    """
    if not type(rec_file_list) == list:
        rec_file_list = [rec_file_list]
    default_input_locs = ['apical']
    # default_rec_locs = ['soma']
    with h5py.File(data_dir+rec_file_list[0]+'.hdf5', 'r') as f:
        if param_names is None:
            param_names = [param_name for param_name in f.values()[0].attrs.keys() if not (param_name == 'input_loc' or param_name == 'equilibrate'
                           or param_name == 'duration')]
        temp_input_locs = []
        temp_rec_locs = []
        for sim in f.itervalues():
            input_loc = sim.attrs['input_loc']
            if not input_loc in temp_input_locs:
                temp_input_locs.append(input_loc)
    # enforce the default order of input and recording locations for plotting, but allow for adding or subtracting
    # sec_types
    input_locs = [input_loc for input_loc in default_input_locs if input_loc in temp_input_locs]+\
                 [input_loc for input_loc in temp_input_locs if not input_loc in default_input_locs]
    distances_soma = {}
    #distances_dend = {}
    param_vals = {}
    for param_name in param_names:
        param_vals[param_name] = {}
    for index, rec_filename in enumerate(rec_file_list):
        for input_loc in input_locs:
            distances_soma[input_loc] = {}
            #distances_dend[input_loc] = {}
            for param_name in param_names:
                param_vals[param_name][input_loc] = {}
        with h5py.File(data_dir+rec_filename+'.hdf5', 'r') as f:
            for sim in f.itervalues():
                input_loc = sim.attrs['input_loc']
                is_terminal = str(sim['rec']['2'].attrs['is_terminal'])
                if is_terminal not in distances_soma[input_loc].keys():
                    distances_soma[input_loc][is_terminal] = []
                    #distances_dend[input_loc][is_terminal] = []
                distances_soma[input_loc][is_terminal].append(sim['rec']['2'].attrs['soma_distance'])
                #distances_dend[input_loc][is_terminal].append(sim['rec']['2'].attrs['soma_distance'] -
                                                                        #sim['rec']['1'].attrs['soma_distance'])
                for param_name in param_names:
                    if is_terminal not in param_vals[param_name][input_loc].keys():
                        param_vals[param_name][input_loc][is_terminal] = []
                    param_vals[param_name][input_loc][is_terminal].append(sim.attrs[param_name])
            fig, axes = plt.subplots(max(2, len(input_locs)), max(2, len(param_names)))
            # fig, axes = plt.subplots(max(2, len(input_locs)*2), max(2, len(param_names)))
            colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
            for i, input_loc in enumerate(input_locs):
                for j, param_name in enumerate(param_names):
                    string_keys = distances_soma[input_loc].keys()
                    terminal_keys = [int(key) for key in string_keys]
                    terminal_keys.sort()
                    terminal_labels = []
                    for key in terminal_keys:
                        if key == 0:
                            terminal_labels.append('not term.')
                        else:
                            terminal_labels.append('terminal')
                    for ind, is_terminal in enumerate([str(key) for key in terminal_keys]):
                        axes[i][j].scatter(distances_soma[input_loc][is_terminal], param_vals[param_name][input_loc][is_terminal],
                                           color=colors[ind], label=terminal_labels[ind])
                        #axes[i + len(input_locs)][j].scatter(distances_dend[input_loc][is_terminal],
                                            # param_vals[param_name][input_loc][is_terminal], color=colors[ind], label=terminal_labels[ind])
                    axes[i][j].legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5)
                    #axes[i + len(input_locs)][j].legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5)
                    axes[i][j].set_xlabel('Distance from Soma (um)')
                    #axes[i + len(input_locs)][j].set_xlabel('Distance from Dendritic Origin (um)')
                    axes[0][j].set_title('Parameter: ' + param_name, fontsize=mpl.rcParams['font.size'])
                axes[i][0].set_ylabel('Synapse Location: '+input_loc+'\n'+param_name)
                #axes[i + len(input_locs)][0].set_ylabel('Synapse Location: ' + input_loc + '\n'+param_name)

    fig.subplots_adjust(hspace=0.25, wspace=0.3, left=0.07, right=0.98, top=0.94, bottom=0.1)
    clean_axes(axes.flatten())
    plt.show()
    plt.close()


def plot_synaptic_param_distribution(cell, env, gid, syn_name, param_name, export=None, overwrite=False, scale_factor=1.,
                                     param_label=None, ylabel='Peak conductance', yunits='uS', svg_title=None,
                                     show=True, sec_types=None, data_dir='data'):
    """
    Plots synapse attributes that are stored in env.synapse_attributes.syn_mech_attr_dict. No simulation is required; this
    method just takes a fully specified cell and plots the relationship between distance and the specified synaptic
    parameter. Used while debugging specification of synaptic parameters.

    Note: exported files can be plotted using plot_mech_param_from_file; give syn_name as the input parameter instead of
    mech_name.

    :param cell: :class:'BiophysCell'
    :param env: :class:'Env'
    :param gid: int
    :param syn_name: str
    :param param_name: str
    :param export: str (name of hdf5 file for export)
    :param overwrite: bool (whether to overwrite or append to potentially existing hdf5 file)
    :param scale_factor: float
    :param param_label: str
    :param ylabel: str
    :param yunits: str
    :param svg_title: str
    :param show: bool (whether to show the plot, or simply save the hdf5 file)
    :param sec_types: list or str
    :param data_dir: str
    :return:
    """
    if svg_title is not None:
        remember_font_size = mpl.rcParams['font.size']
        mpl.rcParams['font.size'] = 20
    if sec_types is None or (isinstance(sec_types, str) and sec_types == 'dend'):
        sec_types = ['basal', 'trunk', 'apical', 'tuft']
    elif isinstance(sec_types, str) and sec_types == 'all':
        sec_types = default_ordered_sec_types
    elif not all(sec_type in default_ordered_sec_types for sec_type in sec_types):
        raise ValueError('plot_mech_param_distribution: unrecognized sec_types: %s' % str(sec_types))
    maxval, minval = 0., 0.
    distances = defaultdict(list)
    param_vals = defaultdict(list)
    sec_types_list = [sec_type for sec_type in sec_types if sec_type in cell.nodes]
    num_colors = 10
    color_x = np.linspace(0., 1., num_colors)
    colors = [cm.Set1(x) for x in color_x]
    syn_attrs = env.synapse_attributes
    sec_index_map = syn_attrs.sec_index_map[gid]
    syn_id_attr_dict = syn_attrs.syn_id_attr_dict[gid]
    for sec_type in sec_types_list:
        if len(cell.nodes[sec_type]) > 0:
            for node in cell.nodes[sec_type]:
                syn_ids = sec_index_map[node.index]
                for syn_id in syn_ids:
                    # TODO: figure out what to do with spine synapses that are not inserted into a branch node
                    this_param_val = syn_attrs.get_mech_attrs(gid, syn_id, syn_name)
                    if this_param_val is not None:
                        param_vals[sec_type].append(this_param_val[param_name])
                        syn_loc = syn_id_attr_dict['syn_locs'][syn_attrs.syn_id_attr_index_map[gid][syn_id]]
                        distances[sec_type].append(get_distance_to_node(cell, cell.tree.root, node, syn_loc))
                        if sec_type == 'basal':
                            distances[sec_type][-1] *= -1
    if len(param_vals) == 0 and export is not None:
        print 'Not exporting to %s; mechanism: %s parameter: %s not found in any sec_type' % \
              (export, syn_name, param_name)
        return
    fig, axes = plt.subplots(1)
    xmax0 = 0.1
    xmin0 = 0.
    for i, sec_type in enumerate(param_vals):
        if param_vals[sec_type]:
            axes.scatter(distances[sec_type], param_vals[sec_type], color=colors[i], label=sec_type, alpha=0.5)
            if maxval is None:
                maxval = max(param_vals[sec_type])
            else:
                maxval = max(maxval, max(param_vals[sec_type]))
            if minval is None:
                minval = min(param_vals[sec_type])
            else:
                minval = min(minval, min(param_vals[sec_type]))
            xmax0 = max(xmax0, max(distances[sec_type]))
            xmin0 = min(xmin0, min(distances[sec_type]))
    axes.set_xlabel('Distance to soma (um)')
    xmin = xmin0 - 0.01 * (xmax0 - xmin0)
    xmax = xmax0 + 0.01 * (xmax0 - xmin0)
    axes.set_xlim(xmin, xmax)
    axes.set_ylabel(ylabel + ' (' + yunits + ')')
    if (maxval is not None) and (minval is not None):
        buffer = 0.01 * (maxval - minval)
        axes.set_ylim(minval - buffer, maxval + buffer)
    if param_label is not None:
        axes.set_title(param_label, fontsize=mpl.rcParams['font.size'])
    axes.legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5, fontsize=mpl.rcParams['font.size'])
    clean_axes(axes)

    if not svg_title is None:
        if param_label is not None:
            svg_title = svg_title + ' - ' + param_label + '.svg'
        else:
            svg_title = svg_title + ' - ' + syn_name + '_' + param_name + ' distribution.svg'
        fig.set_size_inches(5.27, 4.37)
        fig.savefig(data_dir + svg_title, format='svg', transparent=True)
    if show:
        plt.show()
    plt.close()
    if svg_title is not None:
        mpl.rcParams['font.size'] = remember_font_size

    if export is not None:
        if overwrite:
            f = h5py.File(data_dir + '/' + export, 'w')
        else:
            f = h5py.File(data_dir + '/' + export, 'a')
        if 'mech_file_path' in f.attrs.keys():
            if not (f.attrs['mech_file_path'] == '{}'.format(cell.mech_file_path)):
                raise Exception('Specified mechanism filepath {} does not match the mechanism filepath '
                                'of the cell {}'.format(f.attrs['mech_file_path'], cell.mech_file_path))
        else:
            f.attrs['mech_file_path'] = '{}'.format(cell.mech_file_path)
        # TODO: Use enumerated groups to store multiple versions of the same mech param in one file.
        if syn_name in f:
            if param_name in f[syn_name]:
                return
            else:
                f[syn_name].create_group(param_name)
        else:
            f.create_group(syn_name)
            f[syn_name].create_group(param_name)
        for sec_type in param_vals:
            f[syn_name][param_name].create_group(sec_type)
            f[syn_name][param_name][sec_type].create_dataset('values', data=param_vals[sec_type])
            if not 'distances' in f:
                f.create_group('distances')
            f['distances'].create_group(sec_type)
            f['distances'][sec_type].create_dataset('values', data=distances[sec_type])
        f.close()


def plot_synaptic_attribute_distribution(cell, env, gid, syn_name, param_name, filters=None, from_mech_attrs=True,
                                         from_target_attrs=False, export=None, overwrite=False,
                                         scale_factor=1., param_label=None, ylabel='Peak conductance', yunits='uS',
                                         svg_title=None, show=True, sec_types=None, data_dir='data'):
    """
    Plots values of synapse attributes found in point processes and NetCons of a Hoc Cell. No simulation is required;
    this method just takes a fully specified cell and plots the relationship between distance and the specified synaptic
    parameter.

    Note: exported files can be plotted using plot_mech_param_from_file; give syn_name as the input parameter instead of
    mech_name.

    :param cell: :class:'BiophysCell'
    :param env: :class:'Env'
    :param gid: int
    :param syn_name: str
    :param param_name: str
    :param filters: dict with enumerated type
    :param from_mech_attrs: bool
    :param from_target_attrs: bool
    :param export: str (name of hdf5 file for export)
    :param overwrite: bool (whether to overwrite or append to potentially existing hdf5 file)
    :param scale_factor: float
    :param param_label: str
    :param ylabel: str
    :param yunits: str
    :param svg_title: str
    :param show: bool (whether to show the plot, or simply save the hdf5 file)
    :param sec_types: list or str
    :param data_dir: str
    :return:
    """
    if svg_title is not None:
        remember_font_size = mpl.rcParams['font.size']
        mpl.rcParams['font.size'] = 20
    if sec_types is None or (isinstance(sec_types, str) and sec_types == 'dend'):
        sec_types = ['basal', 'trunk', 'apical', 'tuft']
    elif isinstance(sec_types, str) and sec_types == 'all':
        sec_types = default_ordered_sec_types
    elif not all(sec_type in default_ordered_sec_types for sec_type in sec_types):
        raise ValueError('plot_mech_param_distribution: unrecognized sec_types: %s' % str(sec_types))
    maxval, minval = 0., 0.
    distances = {'mech_attrs': defaultdict(list), 'target_attrs': defaultdict(list)}
    attr_vals = {'mech_attrs': defaultdict(list), 'target_attrs': defaultdict(list)}
    sec_types_list = [sec_type for sec_type in sec_types if sec_type in cell.nodes]
    num_colors = 10
    color_x = np.linspace(0., 1., num_colors)
    colors = [cm.Set1(x) for x in color_x]
    syn_attrs = env.synapse_attributes
    sec_index_map = syn_attrs.sec_index_map[gid]
    syn_id_attr_dict = syn_attrs.syn_id_attr_dict[gid]
    for sec_type in sec_types_list:
        if len(cell.nodes[sec_type]) > 0:
            for node in cell.nodes[sec_type]:
                syn_ids = sec_index_map[node.index]
                if filters is not None:
                    filtered_idxs = get_filtered_syn_indexes(syn_id_attr_dict, syn_ids, **filters)
                    syn_ids = syn_id_attr_dict['syn_ids'][filtered_idxs]
                for syn_id in syn_ids:
                    # TODO: figure out what to do with spine synapses that are not inserted into a branch node
                    if from_mech_attrs:
                        this_param_val = syn_attrs.get_mech_attrs(gid, syn_id, syn_name)
                        if this_param_val is not None:
                            attr_vals['mech_attrs'][sec_type].append(this_param_val[param_name])
                        syn_loc = syn_id_attr_dict['syn_locs'][syn_attrs.syn_id_attr_index_map[gid][syn_id]]
                        distances['mech_attrs'][sec_type].append(get_distance_to_node(cell, cell.tree.root, node, syn_loc))
                        if sec_type == 'basal':
                            distances['mech_attrs'][sec_type][-1] *= -1
                    if from_target_attrs:
                        if syn_attrs.has_netcon(cell.gid, syn_id, syn_name):
                            this_nc = syn_attrs.get_netcon(cell.gid, syn_id, syn_name)
                            attr_vals['target_attrs'][sec_type].append(get_syn_mech_param(syn_name, syn_attrs.syn_param_rules, param_name,
                                                                  mech_names=syn_attrs.syn_mech_names, nc=this_nc))
                            syn_loc = syn_id_attr_dict['syn_locs'][syn_attrs.syn_id_attr_index_map[gid][syn_id]]
                            distances['target_attrs'][sec_type].append(get_distance_to_node(cell, cell.tree.root, node, syn_loc))
                            if sec_type == 'basal':
                                distances['target_attrs'][sec_type][-1] *= -1
    if len(attr_vals) == 0 and export is not None:
        print 'Not exporting to %s; mechanism: %s parameter: %s not found in any sec_type' % \
              (export, syn_name, param_name)
        return
    for type in ['mech_attrs', 'target_attrs']:
        fig, axes = plt.subplots(1)
        xmax0 = 0.1
        xmin0 = 0.
        for i, sec_type in enumerate(attr_vals[type]):
            if attr_vals[type][sec_type]:
                axes.scatter(distances[type][sec_type], attr_vals[type][sec_type], color=colors[i], label=sec_type, alpha=0.5)
                if maxval is None:
                    maxval = max(attr_vals[type][sec_type])
                else:
                    maxval = max(maxval, max(attr_vals[type][sec_type]))
                if minval is None:
                    minval = min(attr_vals[type][sec_type])
                else:
                    minval = min(minval, min(attr_vals[type][sec_type]))
                xmax0 = max(xmax0, max(distances[type][sec_type]))
                xmin0 = min(xmin0, min(distances[type][sec_type]))
        axes.set_xlabel('Distance to soma (um)')
        xmin = xmin0 - 0.01 * (xmax0 - xmin0)
        xmax = xmax0 + 0.01 * (xmax0 - xmin0)
        axes.set_xlim(xmin, xmax)
        axes.set_ylabel(ylabel + ' (' + yunits + ')')
        if (maxval is not None) and (minval is not None):
            buffer = 0.01 * (maxval - minval)
            axes.set_ylim(minval - buffer, maxval + buffer)
        if param_label is not None:
            axes.set_title(param_label + ' from ' + type, fontsize=mpl.rcParams['font.size'])
        else:
            axes.set_title('Plot from ' + type, fontsize=mpl.rcParams['font.size'])
        axes.legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5, fontsize=mpl.rcParams['font.size'])
        clean_axes(axes)

        if not svg_title is None:
            if param_label is not None:
                svg_title = svg_title + ' - ' + param_label + '.svg'
            else:
                svg_title = svg_title + ' - ' + syn_name + '_' + param_name + ' distribution.svg'
            fig.set_size_inches(5.27, 4.37)
            fig.savefig(data_dir + svg_title, format='svg', transparent=True)
    if show:
        plt.show()
    plt.close()
    if svg_title is not None:
        mpl.rcParams['font.size'] = remember_font_size

    if export is not None:
        if overwrite:
            f = h5py.File(data_dir + '/' + export, 'w')
        else:
            f = h5py.File(data_dir + '/' + export, 'a')
        if 'mech_file_path' in f.attrs.keys():
            if not (f.attrs['mech_file_path'] == '{}'.format(cell.mech_file_path)):
                raise Exception('Specified mechanism filepath {} does not match the mechanism filepath '
                                'of the cell {}'.format(f.attrs['mech_file_path'], cell.mech_file_path))
        else:
            f.attrs['mech_file_path'] = '{}'.format(cell.mech_file_path)
        # TODO: Use enumerated groups to store multiple versions of the same mech param in one file.
        if syn_name in f:
            if param_name in f[syn_name]:
                return
            else:
                f[syn_name].create_group(param_name)
        else:
            f.create_group(syn_name)
            f[syn_name].create_group(param_name)
        for type in ['mech_attrs', 'target_attrs']:
            f[syn_name][param_name].create_group(type)
            if not 'distances' in f:
                f.create_group('distances')
            f['distances'].create_group(type)
            for sec_type in attr_vals:
                f[syn_name][param_name][type].create_group(sec_type)
                f[syn_name][param_name][type][sec_type].create_dataset('values', data=attr_vals[type][sec_type])
                f['distances'][type].create_group(sec_type)
                f['distances'][type][sec_type].create_dataset('values', data=distances[type][sec_type])
        f.close()


def plot_mech_param_distribution(cell, mech_name, param_name, export=None, overwrite=False, scale_factor=10000.,
                                 param_label=None, ylabel='Conductance density', yunits='pS/um2', svg_title=None,
                                 show=True, sec_types=None, data_dir='data'):
    """
    Takes a cell as input rather than a file. No simulation is required, this method just takes a fully specified cell
    and plots the relationship between distance and the specified mechanism parameter for all segments in sections of
    the provided sec_types (defaults to just dendritic sec_types). Used while debugging specification of mechanism
    parameters.
    :param cell: :class:'BiophysCell'
    :param mech_name: str
    :param param_name: str
    :param export: str (name of hdf5 file for export)
    :param overwrite: bool (whether to overwrite or append to potentially existing hdf5 file)
    :param scale_factor: float
    :param param_label: str
    :param ylabel: str
    :param yunits: str
    :param svg_title: str
    :param show: bool
    :param sec_types: list or str
    :param data_dir: str (path)
    """
    if svg_title is not None:
        remember_font_size = mpl.rcParams['font.size']
        mpl.rcParams['font.size'] = 20
    if sec_types is None or (isinstance(sec_types, str) and sec_types == 'dend'):
        sec_types = ['basal', 'trunk', 'apical', 'tuft']
    elif isinstance(sec_types, str) and sec_types == 'all':
        sec_types = default_ordered_sec_types
    elif not all(sec_type in default_ordered_sec_types for sec_type in sec_types):
        raise ValueError('plot_mech_param_distribution: unrecognized sec_types: %s' % str(sec_types))
    maxval, minval = 1., 0.
    distances = defaultdict(list)
    param_vals = defaultdict(list)
    sec_types_list = [sec_type for sec_type in sec_types if sec_type in cell.nodes]
    num_colors = 10
    color_x = np.linspace(0., 1., num_colors)
    colors = [cm.Set1(x) for x in color_x]
    for sec_type in sec_types_list:
        if len(cell.nodes[sec_type]) > 0:
            for branch in cell.nodes[sec_type]:
                for seg in [seg for seg in branch.sec if hasattr(seg, mech_name)]:
                    distances[sec_type].append(get_distance_to_node(cell, cell.tree.root, branch, seg.x))
                    if sec_type == 'basal':
                        distances[sec_type][-1] *= -1
                    param_vals[sec_type].append(getattr(getattr(seg, mech_name), param_name) * scale_factor)
    if len(param_vals) == 0 and export is not None:
        print 'Not exporting to %s; mechanism: %s parameter: %s not found in any sec_type' % \
              (export, mech_name, param_name)
        return
    fig, axes = plt.subplots(1)
    xmax0 = 0.1
    xmin0 = 0.
    for i, sec_type in enumerate(param_vals):
        axes.scatter(distances[sec_type], param_vals[sec_type], color=colors[i], label=sec_type, alpha=0.5)
        if maxval is None:
            maxval = max(param_vals[sec_type])
        else:
            maxval = max(maxval, max(param_vals[sec_type]))
        if minval is None:
            minval = min(param_vals[sec_type])
        else:
            minval = min(minval, min(param_vals[sec_type]))
        xmax0 = max(xmax0, max(distances[sec_type]))
        xmin0 = min(xmin0, min(distances[sec_type]))
    axes.set_xlabel('Distance to soma (um)')
    xmin = xmin0 - 0.01 * (xmax0 - xmin0)
    xmax = xmax0 + 0.01 * (xmax0 - xmin0)
    axes.set_xlim(xmin, xmax)
    axes.set_ylabel(ylabel + ' (' + yunits + ')')
    if (maxval is not None) and (minval is not None):
        buffer = 0.01 * (maxval - minval)
        axes.set_ylim(minval - buffer, maxval + buffer)
    if param_label is not None:
        axes.set_title(param_label, fontsize=mpl.rcParams['font.size'])
    axes.legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5, fontsize=mpl.rcParams['font.size'])
    clean_axes(axes)

    if not svg_title is None:
        if param_label is not None:
            svg_title = svg_title + ' - ' + param_label + '.svg'
        else:
            svg_title = svg_title + ' - ' + mech_name + '_' + param_name + ' distribution.svg'
        fig.set_size_inches(5.27, 4.37)
        fig.savefig(data_dir + svg_title, format='svg', transparent=True)
    if show:
        plt.show()
    plt.close()
    if svg_title is not None:
        mpl.rcParams['font.size'] = remember_font_size

    if export is not None:
        if overwrite:
            f = h5py.File(data_dir + '/' + export, 'w')
        else:
            f = h5py.File(data_dir + '/' + export, 'a')
        if 'mech_file_path' in f.attrs.keys():
            if not f.attrs['mech_file_path'] == cell.mech_file_path:
                raise Exception('Specified mechanism file path: %s does not match the mechanism file path '
                                'of the cell: %s' % (f.attrs['mech_file_path'], cell.mech_file_path))
        else:
            f.attrs['mech_file_path'] = cell.mech_file_path
        # TODO: Use enumerated groups to store multiple versions of the same mech param in one file.
        if mech_name in f:
            if param_name in f[mech_name]:
                return
            else:
                f[mech_name].create_group(param_name)
        else:
            f.create_group(mech_name)
            f[mech_name].create_group(param_name)
        for sec_type in param_vals:
            f[mech_name][param_name].create_group(sec_type)
            f[mech_name][param_name][sec_type].create_dataset('values', data=param_vals[sec_type])
            if not 'distances' in f:
                f.create_group('distances')
            f['distances'].create_group(sec_type)
            f['distances'][sec_type].create_dataset('values', data=distances[sec_type])
        f.close()


def plot_cable_param_distribution(cell, mech_name, export=None, overwrite=False, scale_factor=1., param_label=None,
                                  ylabel='Specific capacitance', yunits='uF/cm2', svg_title=None, show=True,
                                  data_dir='data'):
    """
    Takes a cell as input rather than a file. No simulation is required, this method just takes a fully specified cell
    and plots the relationship between distance and the specified mechanism parameter for all dendritic segments. Used
    while debugging specification of mechanism parameters.
    :param cell: :class:'BiophysCell'
    :param mech_name: str
    :param param_name: str
    :param export: str (name of hdf5 file for export)
    :param overwrite: bool (whether to overwrite or append to potentially existing hdf5 file)
    :param scale_factor: float
    :param param_label: str
    :param ylabel: str
    :param yunits: str
    :param svg_title: str
    :param data_dir: str (path)
    """
    if svg_title is not None:
        remember_font_size = mpl.rcParams['font.size']
        mpl.rcParams['font.size'] = 20
    sec_types = default_ordered_sec_types
    fig, axes = plt.subplots(1)
    maxval, minval = 1., 0.
    distances = defaultdict(list)
    param_vals = defaultdict(list)
    sec_types_list = [sec_type for sec_type in sec_types if sec_type in cell.nodes]
    num_colors = len(sec_types_list)
    color_x = np.linspace(0., 1., num_colors)
    colors = [cm.Set1(x) for x in color_x]
    for sec_type in sec_types_list:
        if len(cell.nodes[sec_type]) > 0:
            for branch in cell.nodes[sec_type]:
                if mech_name == 'Ra':
                    distances[sec_type].append(get_distance_to_node(cell, cell.tree.root, branch))
                    if sec_type == 'basal':
                        distances[sec_type][-1] *= -1
                    param_vals[sec_type].append(getattr(branch.sec, mech_name) * scale_factor)
                else:
                    for seg in [seg for seg in branch.sec if hasattr(seg, mech_name)]:
                        distances[sec_type].append(get_distance_to_node(cell, cell.tree.root, branch, seg.x))
                        if sec_type == 'basal':
                            distances[sec_type][-1] *= -1
                        param_vals[sec_type].append(getattr(seg, mech_name) * scale_factor)
    xmax0 = 0.1
    xmin0 = 0.
    for i, sec_type in enumerate(param_vals):
        axes.scatter(distances[sec_type], param_vals[sec_type], color=colors[i], label=sec_type, alpha=0.5)
        if maxval is None:
            maxval = max(param_vals[sec_type])
        else:
            maxval = max(maxval, max(param_vals[sec_type]))
        if minval is None:
            minval = min(param_vals[sec_type])
        else:
            minval = min(minval, min(param_vals[sec_type]))
        xmax0 = max(xmax0, max(distances[sec_type]))
        xmin0 = min(xmin0, min(distances[sec_type]))
    axes.set_xlabel('Distance to soma (um)')
    xmin = xmin0 - 0.01 * (xmax0 - xmin0)
    xmax = xmax0 + 0.01 * (xmax0 - xmin0)
    axes.set_xlim(xmin, xmax)
    axes.set_ylabel(ylabel + ' (' + yunits + ')')
    if (maxval is not None) and (minval is not None):
        buffer = 0.01 * (maxval - minval)
        axes.set_ylim(minval - buffer, maxval + buffer)
    if param_label is not None:
        axes.set_title(param_label, fontsize=mpl.rcParams['font.size'])
    axes.legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5, fontsize=mpl.rcParams['font.size'])
    clean_axes(axes)
    axes.tick_params(direction='out')
    if not svg_title is None:
        if param_label is not None:
            svg_title = svg_title + ' - ' + param_label + '.svg'
        else:
            svg_title = svg_title + ' - ' + mech_name + '_' + ' distribution.svg'
        fig.set_size_inches(5.27, 4.37)
        fig.savefig(data_dir + svg_title, format='svg', transparent=True)
    if show:
        plt.show()
    plt.close()
    if svg_title is not None:
        mpl.rcParams['font.size'] = remember_font_size

    if export is not None:
        if overwrite:
            f = h5py.File(data_dir + '/' + export, 'w')
        else:
            f = h5py.File(data_dir + '/' + export, 'a')
        if 'mech_file_path' in f.attrs.keys():
            if not (f.attrs['mech_file_path'] == '{}'.format(cell.mech_file_path)):
                raise Exception('Specified mechanism filepath {} does not match the mechanism filepath '
                                'of the cell {}'.format(f.attrs['mech_file_path'], cell.mech_file_path))
        else:
            f.attrs['mech_file_path'] = '{}'.format(cell.mech_file_path)
        if mech_name in f:
            return
        else:
            f.create_group(mech_name)
        for sec_type in param_vals:
            f[mech_name].create_group(sec_type)
            f[mech_name][sec_type].create_dataset('values', data=param_vals[sec_type])
        if not 'distances' in f:
            f.create_group('distances')
            for sec_type in distances:
                f['distances'].create_group(sec_type)
                f['distances'][sec_type].create_dataset('values', data=distances[sec_type])
        f.close()


def plot_mech_param_from_file(mech_name, param_name, filenames, file_labels=None, param_label=None,
                              ylabel='Conductance density', yunits='pS/um2', svg_title=None, data_dir='data'):
    """
    Takes in a list of files, and superimposes plots of distance vs. the provided mechanism parameter for all sec_types
    found in each file.
    :param mech_name: str
    :param param_name: str
    :param filenames: list of hdf filenames
    :param filename_labels: list of filename labels
    :param param_label: str
    :param ylabel: str
    :param yunits: str
    :param svg_title: str
    :param data_dir: str (path)
    """
    if svg_title is not None:
        remember_font_size = mpl.rcParams['font.size']
        mpl.rcParams['font.size'] = 20
    fig, axes = plt.subplots(1)
    max_param_val, min_param_val = 0.1, 0.
    max_dist, min_dist = None, 0.
    num_colors = 10
    markers = mlines.Line2D.filled_markers
    color_x = np.linspace(0., 1., num_colors)
    colors = [cm.Set1(x) for x in color_x]
    distances = defaultdict(lambda: defaultdict(list))
    param_vals = defaultdict(lambda: defaultdict(list))
    marker_dict = {}
    if file_labels is None:
        file_labels = filenames
    for i, file in enumerate(filenames):
        file_path = data_dir + '/' + file
        if os.path.isfile(file_path):
            with h5py.File(file_path, 'r') as f:
                if mech_name not in f:
                    raise Exception('Specified mechanism name is not found in the file {}'.format(file))
                elif param_name is not None and param_name not in f[mech_name]:
                    raise Exception('Specified parameter name is not found in the file {}'.format(file))
                if param_name is None:
                    for sec_type in f[mech_name]:
                        param_vals[file_labels[i]][sec_type].extend(f[mech_name][sec_type]['values'][:])
                        distances[file_labels[i]][sec_type].extend(f['distances'][sec_type]['values'][:])
                else:
                    for sec_type in f[mech_name][param_name].keys():
                        param_vals[file_labels[i]][sec_type].extend(f[mech_name][param_name][sec_type]['values'][:])
                        distances[file_labels[i]][sec_type].extend(f['distances'][sec_type]['values'][:])
            for sec_type in param_vals[file_labels[i]]:
                if sec_type not in marker_dict:
                    j = len(marker_dict)
                    marker_dict[sec_type] = markers[j]
                marker = marker_dict[sec_type]
                axes.scatter(distances[file_labels[i]][sec_type], param_vals[file_labels[i]][sec_type], color=colors[i],
                             label=sec_type+'_'+file_labels[i], alpha=0.5, marker=marker)
                if max_param_val is None:
                    max_param_val = max(param_vals[file_labels[i]][sec_type])
                else:
                    max_param_val = max(max_param_val, max(param_vals[file_labels[i]][sec_type]))
                if min_param_val is None:
                    min_param_val = min(param_vals[file_labels[i]][sec_type])
                else:
                    min_param_val = min(min_param_val, min(param_vals[file_labels[i]][sec_type]))
                if max_dist is None:
                    max_dist = max(distances[file_labels[i]][sec_type])
                else:
                    max_dist = max(max_dist, max(distances[file_labels[i]][sec_type]))
                if min_dist is None:
                    min_dist = min(distances[file_labels[i]][sec_type])
                else:
                    min_dist = min(min_dist, min(distances[file_labels[i]][sec_type]))
    axes.set_xlabel('Distance to soma (um)')
    min_dist = min(0., min_dist)
    xmin = min_dist - 0.01 * (max_dist - min_dist)
    xmax = max_dist + 0.01 * (max_dist - min_dist)
    axes.set_xlim(xmin, xmax)
    axes.set_ylabel(ylabel + ' (' + yunits + ')')
    if (max_param_val is not None) and (min_param_val is not None):
        buffer = 0.1 * (max_param_val - min_param_val)
    axes.set_ylim(min_param_val - buffer, max_param_val + buffer)
    if param_label is not None:
        axes.set_title(param_label, fontsize=mpl.rcParams['font.size'])
    axes.legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5, fontsize=mpl.rcParams['font.size'])
    clean_axes(axes)
    axes.tick_params(direction='out')
    if not svg_title is None:
        if param_label is not None:
            svg_title = svg_title + ' - ' + param_label + '.svg'
        elif param_name is None:
            svg_title = svg_title + ' - ' + mech_name + '_' + ' distribution.svg'
        else:
            svg_title = svg_title + ' - ' + mech_name + '_' + param_name + ' distribution.svg'
        fig.set_size_inches(5.27, 4.37)
        fig.savefig(data_dir + svg_title, format='svg', transparent=True)
    plt.show()
    plt.close()
    if svg_title is not None:
        mpl.rcParams['font.size'] = remember_font_size


def plot_sum_mech_param_distribution(cell, mech_param_list, scale_factor=10000., param_label=None,
                                 ylabel='Conductance density', yunits='pS/um2', svg_title=None):
    """
    Takes a cell as input rather than a file. No simulation is required, this method just takes a fully specified cell
    and plots the relationship between distance and the specified mechanism parameter for all dendritic segments. Used
    while debugging specification of mechanism parameters.
    :param cell: :class:'HocCell'
    :param mech_param_list: list of tuple of str
    :param scale_factor: float
    :param ylabel: str
    :param yunits: str
    :param svg_title: str
    """
    colors = ['k', 'r', 'c', 'y', 'm', 'g', 'b']
    dend_types = ['basal', 'trunk', 'apical', 'tuft']

    if svg_title is not None:
        remember_font_size = mpl.rcParams['font.size']
        mpl.rcParams['font.size'] = 20
    fig, axes = plt.subplots(1)
    maxval, minval = None, None
    for i, sec_type in enumerate(dend_types):
        distances = []
        param_vals = []
        for branch in cell.get_nodes_of_subtype(sec_type):
            for seg in branch.sec:
                this_param_val = 0.
                this_distance = None
                for mech_name, param_name in mech_param_list:
                    if hasattr(seg, mech_name):
                        if this_distance is None:
                            this_distance = cell.get_distance_to_node(cell.tree.root, branch, seg.x)
                            if sec_type == 'basal':
                                this_distance *= -1
                        this_param_val += getattr(getattr(seg, mech_name), param_name) * scale_factor
                if this_distance is not None:
                    distances.append(this_distance)
                    param_vals.append(this_param_val)
        if param_vals:
            axes.scatter(distances, param_vals, color=colors[i], label=sec_type)
            if maxval is None:
                maxval = max(param_vals)
            else:
                maxval = max(maxval, max(param_vals))
            if minval is None:
                minval = min(param_vals)
            else:
                minval = min(minval, min(param_vals))
    axes.set_xlabel('Distance to soma (um)')
    axes.set_xlim(-200., 525.)
    axes.set_xticks([-150., 0., 150., 300., 450.])
    axes.set_ylabel(ylabel+' ('+yunits+')')
    buffer = 0.1 * (maxval - minval)
    axes.set_ylim(minval-buffer, maxval+buffer)
    if param_label is not None:
        plt.title(param_label, fontsize=mpl.rcParams['font.size'])
    plt.legend(loc='best', scatterpoints=1, frameon=False, framealpha=0.5, fontsize=mpl.rcParams['font.size'])
    clean_axes(axes)
    axes.tick_params(direction='out')
    if not svg_title is None:
        if param_label is not None:
            svg_title = svg_title+' - '+param_label+'.svg'
        else:
            mech_name, param_name = mech_param_list[0]
            svg_title = svg_title+' - '+mech_name+'_'+param_name+' distribution.svg'
        fig.set_size_inches(5.27, 4.37)
        fig.savefig(data_dir + svg_title, format='svg', transparent=True)
    plt.show()
    plt.close()
    if svg_title is not None:
        mpl.rcParams['font.size'] = remember_font_size


def plot_absolute_energy(storage):
    fig, axes = plt.subplots(1)
    colors = list(cm.rainbow(np.linspace(0, 1, len(storage.history))))
    this_attr = 'objectives'
    for j, population in enumerate(storage.history):
        axes.scatter([indiv.rank for indiv in population],
                    [np.sum(getattr(indiv, this_attr)) for indiv in population],
                    c=colors[j], alpha=0.05)
        axes.scatter([indiv.rank for indiv in storage.survivors[j]],
                    [np.sum(getattr(indiv, this_attr)) for indiv in storage.survivors[j]], c=colors[j], alpha=0.5)
    axes.set_xlabel('Rank')
    axes.set_ylabel('Summed Objectives')


def plot_best_norm_features_boxplot(storage, target_val, target_range):
    """

    :return:
    """
    #Ensure that f_I_slope is in target_val with a value of 53.
    fig, axes = plt.subplots(1)
    labels = target_val.keys()
    # y_values = range(len(y_labels))
    final_survivors = storage.survivors[-1]
    norm_feature_vals = {}
    colors = list(cm.rainbow(np.linspace(0, 1, len(labels))))
    for survivor in final_survivors:
        for i, feature in enumerate(storage.feature_names):
            if feature in target_val:
                if feature not in norm_feature_vals:
                    norm_feature_vals[feature] = []
                if (feature == 'slow_depo' and getattr(survivor, 'features')[i] < target_val[feature]) or \
                        (feature == 'AHP' and getattr(survivor, 'features')[i] < target_val[feature]):
                    normalized_val = 0.
                else:
                    normalized_val = (getattr(survivor, 'features')[i] - target_val[feature]) / target_range[feature]
                norm_feature_vals[feature].append(normalized_val)
    x_values_list = [norm_feature_vals[feature] for feature in labels]
    """
    for i, y_value in enumerate(y_values):
        axes.scatter(x_values_list[i], y_value * np.ones(len(x_values_list[i])), c=colors[i])
    """
    bplot = axes.boxplot(x_values_list, vert=False, labels=labels, patch_artist=True)
    colors = list(cm.rainbow(np.linspace(0, 1, len(labels))))
    for patch, color in zip(bplot['boxes'], colors):
        patch.set_facecolor(color)
    axes.set_xlabel('Normalized Features')
    #axes.set_yticks(y_values)
    #axes.set_yticklabels(y_labels)
    axes.set_title('Best Parameter Sets')
    clean_axes(axes)
    fig.tight_layout()
    plt.show()
    plt.close()


def plot_best_norm_features_scatter(storage, target_val, target_range):
    """

    :return:
    """
    #Ensure that f_I_slope is in target_val with a value of 53.
    """
    {'ADP': 2.0, 'AHP': 0.8, 'ais_delay': 0.02, 'dend R_inp': 75.0, 'dend_amp': 0.06, 'rebound_firing': 0.2,
     'slow_depo': 2.0, 'soma R_inp': 59.0, 'soma_peak': 8.0, 'spont_firing': 0.2, 'v_th': -9.600000000000001,
     'vm_stability': 2.0, 'f_I_slope': 10.6}
    """
    orig_fontsize = mpl.rcParams['font.size']
    mpl.rcParams['font.size'] = 16.
    fig, axes = plt.subplots(1)
    y_labels = target_val.keys()
    y_values = range(len(y_labels))
    final_survivors = storage.survivors[-1]
    norm_feature_vals = {}
    colors = list(cm.rainbow(np.linspace(0, 1, len(y_labels))))
    for survivor in final_survivors:
        for i, feature in enumerate(storage.feature_names):
            if feature in target_val:
                if feature not in norm_feature_vals:
                    norm_feature_vals[feature] = []
                if (feature == 'slow_depo' and getattr(survivor, 'features')[i] < target_val[feature]) or \
                        (feature == 'AHP' and getattr(survivor, 'features')[i] < target_val[feature]):
                    normalized_val = 0.
                else:
                    normalized_val = (getattr(survivor, 'features')[i] - target_val[feature]) / target_range[feature]
                norm_feature_vals[feature].append(normalized_val)
    x_values_list = [norm_feature_vals[feature] for feature in y_labels]
    for i, y_value in enumerate(y_values):
        axes.scatter(x_values_list[i], y_value * np.ones(len(x_values_list[i])), c=colors[i], alpha=0.4)
    axes.set_xlabel('Normalized Features')
    axes.set_xlim(-2.5, 2.5)
    axes.set_yticks(y_values)
    axes.set_yticklabels(y_labels)
    axes.set_title('Best Parameter Sets', fontsize=mpl.rcParams['font.size'] + 2)
    clean_axes(axes)
    fig.tight_layout()
    plt.show()
    plt.close()
    mpl.rcParams['font.size'] = orig_fontsize


def plot_parallel_optimize_exported_f_I_features(processed_export_file_path):
    """

    :param processed_export_file_path: str (path)
    """
    orig_fontsize = mpl.rcParams['font.size']
    # mpl.rcParams['font.size'] = 20.
    description = 'f_I_features'
    with h5py.File(processed_export_file_path, 'r') as f:
        group  = f[description]
        amps = group['amps']
        fig, axes = plt.subplots(1, 2)
        axes[0].scatter(amps, group['adi'], label='Simulation', c='r', alpha=0.6)
        axes[0].scatter(amps, group['exp_adi'], label='Experiment', c='k', alpha=0.6)
        axes[0].legend(loc='best', frameon=False, framealpha=0.5)
        axes[0].set_xlabel('Current injection amp (nA)')
        axes[0].set_ylabel('Adaptation index')
        axes[1].scatter(amps, group['f_I'], label='Simulation', c='r', alpha=0.6)
        axes[1].scatter(amps, group['exp_f_I'], label='Experiment', c='k', alpha=0.6)
        axes[1].legend(loc='best', frameon=False, framealpha=0.5)
        axes[1].set_xlabel('Current injection amp (nA)')
        axes[1].set_ylabel('Firing Rate (Hz)')
    clean_axes(axes)
    fig.tight_layout()
    plt.show()
    plt.close()
    mpl.rcParams['font.size'] = orig_fontsize


def plot_parallel_optimize_exported_traces(export_file_path):
    """

    :param export_file_path: str (path)
    """
    orig_fontsize = mpl.rcParams['font.size']
    # mpl.rcParams['font.size'] = 20.
    with h5py.File(export_file_path, 'r') as f:
        for trial in f.itervalues():
            # amplitude = trial.attrs['amp']
            fig, axes = plt.subplots(1)
            for rec in trial['rec'].itervalues():
                axes.plot(trial['time'], rec, label=rec.attrs['description'])
            axes.legend(loc='best', frameon=False, framealpha=0.5)
            axes.set_xlabel('Time (ms)')
            axes.set_ylabel('Vm (mV)')
            axes.set_title('%s: %s' % (trial.attrs['title'], trial.attrs['description']))
            clean_axes(axes)
            fig.tight_layout()
    plt.show()
    plt.close()
    mpl.rcParams['font.size'] = orig_fontsize


def plot_na_gradient_params(x_dict):
    """

    :param x_dict: dict
    :return:
    """
    orig_fontsize = mpl.rcParams['font.size']
    mpl.rcParams['font.size'] = 20.
    fig, axes = plt.subplots(1)
    x_labels = ['axon', 'AIS', 'soma', 'dend']
    x_values = range(len(x_labels))
    colors = ['b', 'c', 'g', 'r']
    y_values = [x_dict['axon.gbar_nax'], x_dict['ais.gbar_nax'], x_dict['soma.gbar_nas'], x_dict['dend.gbar_nas']]
    for i in x_values:
        axes.scatter(x_values[i], y_values[i], c=colors[i])
    # axes.set_ylim(-2.5, 2.5)
    axes.set_xticks(x_values)
    axes.set_xticklabels(x_labels)
    axes.set_ylabel('gmax_na')
    clean_axes(axes)
    fig.tight_layout()
    plt.show()
    plt.close()
    mpl.rcParams['font.size'] = orig_fontsize

